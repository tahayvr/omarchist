use dirs::home_dir;
use json_comments::StripComments;
use serde::{Deserialize, Serialize};
use serde_json::{json, Map, Value};
use std::collections::{BTreeMap, HashSet};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

const OMARCHIST_WAYBAR_SUBDIR: &str = ".config/omarchist/waybar";
const WAYBAR_PROFILES_DIR_NAME: &str = "profiles";
const WAYBAR_MANIFEST_FILE_NAME: &str = "manifest.json";
const PROFILE_CONFIG_FILE_NAME: &str = "config.jsonc";
const PROFILE_STYLE_FILE_NAME: &str = "style.css";
const DEFAULT_PROFILE_ID: &str = "omarchy-default";
const DEFAULT_PROFILE_NAME: &str = "Omarchy Default";

const KNOWN_MODULE_KEYS: &[&str] = &[
    "custom/omarchy",
    "hyprland/workspaces",
    "hyprland/window",
    "clock",
    "custom/update",
    "custom/screenrecording-indicator",
    "group/tray-expander",
    "custom/expand-icon",
    "tray",
    "bluetooth",
    "network",
    "pulseaudio",
    "cpu",
    "battery",
];

const CONFIG_HEADER: &str = "// Generated by Omarchist Waybar editor\n// Manual edits for unsupported fields will be preserved.\n";

const STYLE_HEADER: &str = "/* Generated by Omarchist Waybar editor */\n/* Manual edits will be preserved when possible */\n";

#[derive(Debug, thiserror::Error)]
pub enum WaybarConfigError {
    #[error("Unable to resolve home directory")]
    HomeDirNotFound,
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Failed to parse Waybar config: {0}")]
    Parse(String),
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("Waybar profile already exists: {0}")]
    ProfileExists(String),
    #[error("Waybar profile not found: {0}")]
    ProfileNotFound(String),
    #[error("Waybar profile name is invalid")]
    InvalidProfileName,
    #[error("The default Waybar profile cannot be deleted")]
    CannotDeleteDefaultProfile,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct WaybarLayout {
    pub left: Vec<String>,
    pub center: Vec<String>,
    pub right: Vec<String>,
    pub hidden: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarGlobals {
    pub layer: String,
    pub position: String,
    pub height: f64,
    pub spacing: f64,
    pub background: String,
    pub foreground: String,
}

impl Default for WaybarGlobals {
    fn default() -> Self {
        Self {
            layer: "top".to_string(),
            position: "top".to_string(),
            height: 26.0,
            spacing: 0.0,
            background: "#1e1e1e".to_string(),
            foreground: "#d4d4d8".to_string(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct WaybarProfileRecord {
    id: String,
    name: String,
    is_default: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct WaybarProfileManifest {
    version: u32,
    active_profile_id: Option<String>,
    profiles: Vec<WaybarProfileRecord>,
}

impl Default for WaybarProfileManifest {
    fn default() -> Self {
        Self {
            version: 1,
            active_profile_id: Some(DEFAULT_PROFILE_ID.to_string()),
            profiles: vec![WaybarProfileRecord {
                id: DEFAULT_PROFILE_ID.to_string(),
                name: DEFAULT_PROFILE_NAME.to_string(),
                is_default: true,
            }],
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileSummary {
    pub id: String,
    pub name: String,
    pub is_default: bool,
    pub is_active: bool,
    pub is_protected: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarConfigSnapshot {
    pub layout: WaybarLayout,
    pub globals: WaybarGlobals,
    pub modules: BTreeMap<String, Value>,
    pub passthrough: Value,
    pub raw_json: String,
    pub profile_id: Option<String>,
    pub style_css: String,
}

impl Default for WaybarConfigSnapshot {
    fn default() -> Self {
        Self {
            layout: WaybarLayout::default(),
            globals: WaybarGlobals::default(),
            modules: default_modules_map(),
            passthrough: json!({
                "reload_style_on_change": true
            }),
            raw_json: String::new(),
            profile_id: None,
            style_css: default_style_css(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileListResponse {
    pub profiles: Vec<WaybarProfileSummary>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileChangeResponse {
    pub snapshot: WaybarConfigSnapshot,
    pub profiles: Vec<WaybarProfileSummary>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SaveWaybarConfigPayload {
    pub layout: WaybarLayout,
    pub globals: WaybarGlobals,
    pub modules: BTreeMap<String, Value>,
    pub passthrough: Value,
    pub style_css: Option<String>,
}

pub struct WaybarConfigService {
    config_path: PathBuf,
    style_path: PathBuf,
    profiles_dir: PathBuf,
    manifest_path: PathBuf,
    manifest: WaybarProfileManifest,
}

impl WaybarConfigService {
    pub fn new() -> Result<Self, WaybarConfigError> {
        let home = home_dir().ok_or(WaybarConfigError::HomeDirNotFound)?;

        let mut config_path = home.clone();
        config_path.push(".config/waybar/config.jsonc");

        let mut style_path = home.clone();
        style_path.push(".config/waybar/style.css");

        let mut omarchist_dir = home.clone();
        omarchist_dir.push(OMARCHIST_WAYBAR_SUBDIR);

        let mut profiles_dir = omarchist_dir.clone();
        profiles_dir.push(WAYBAR_PROFILES_DIR_NAME);

        let mut manifest_path = omarchist_dir.clone();
        manifest_path.push(WAYBAR_MANIFEST_FILE_NAME);

        if !profiles_dir.exists() {
            fs::create_dir_all(&profiles_dir)?;
        }

        let manifest = if manifest_path.exists() {
            let contents = fs::read_to_string(&manifest_path)?;
            serde_json::from_str::<WaybarProfileManifest>(&contents).unwrap_or_default()
        } else {
            WaybarProfileManifest::default()
        };

        let mut service = Self {
            config_path,
            style_path,
            profiles_dir,
            manifest_path,
            manifest,
        };

        service.ensure_manifest_integrity()?;
        Ok(service)
    }

    pub fn load_snapshot(&mut self) -> Result<WaybarConfigSnapshot, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let (value, raw_json) = self.load_profile_value(&active_id)?;
        let style_css = self.load_profile_style(&active_id)?;
        self.sync_profile_to_live(&active_id)?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(active_id));
        Ok(snapshot)
    }

    pub fn save_snapshot(
        &mut self,
        payload: &SaveWaybarConfigPayload,
    ) -> Result<WaybarConfigSnapshot, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let global_defaults = WaybarGlobals::default();

        let mut seen = HashSet::new();
        let left = unique_ordered(payload.layout.left.clone(), &mut seen);
        let center = unique_ordered(payload.layout.center.clone(), &mut seen);
        let right = unique_ordered(payload.layout.right.clone(), &mut seen);

        let mut root_map = match payload.passthrough.clone() {
            Value::Object(map) => map,
            _ => Map::new(),
        };

        root_map.insert(
            "layer".to_string(),
            Value::String(payload.globals.layer.clone()),
        );
        root_map.insert(
            "position".to_string(),
            Value::String(payload.globals.position.clone()),
        );
        root_map.insert(
            "spacing".to_string(),
            Value::Number(number_from_f64(
                payload.globals.spacing,
                global_defaults.spacing,
            )),
        );
        root_map.insert(
            "modules-left".to_string(),
            Value::Array(left.iter().map(|id| Value::String(id.clone())).collect()),
        );
        root_map.insert(
            "modules-center".to_string(),
            Value::Array(center.iter().map(|id| Value::String(id.clone())).collect()),
        );
        root_map.insert(
            "modules-right".to_string(),
            Value::Array(right.iter().map(|id| Value::String(id.clone())).collect()),
        );

        root_map.insert(
            "height".to_string(),
            Value::Number(number_from_f64(
                payload.globals.height,
                global_defaults.height,
            )),
        );

        for key in KNOWN_MODULE_KEYS {
            root_map.remove(*key);
        }

        let defaults = default_modules_map();
        for key in KNOWN_MODULE_KEYS {
            let value = payload.modules.get(*key).cloned().unwrap_or_else(|| {
                defaults
                    .get(*key)
                    .cloned()
                    .unwrap_or(Value::Object(Map::new()))
            });
            root_map.insert((*key).to_string(), value);
        }

        let mut omarchist = match root_map.remove("_omarchist") {
            Some(Value::Object(map)) => map,
            _ => Map::new(),
        };
        let mut globals_map = Map::new();

        if payload.globals.background != global_defaults.background {
            globals_map.insert(
                "background".to_string(),
                Value::String(payload.globals.background.clone()),
            );
        }
        if payload.globals.foreground != global_defaults.foreground {
            globals_map.insert(
                "foreground".to_string(),
                Value::String(payload.globals.foreground.clone()),
            );
        }

        if !globals_map.is_empty() {
            omarchist.insert("globals".to_string(), Value::Object(globals_map));
        }
        if !omarchist.is_empty() {
            root_map.insert("_omarchist".to_string(), Value::Object(omarchist));
        }

        let config_value = Value::Object(root_map);
        let profile_path = self.profile_config_path(&active_id);
        write_value_to_path(&profile_path, &config_value)?;
        write_value_to_path(&self.config_path, &config_value)?;

        // Handle CSS styling
        let style_css = payload
            .style_css
            .clone()
            .unwrap_or_else(|| default_style_css());
        let profile_style_path = self.profile_style_path(&active_id);
        write_style_to_path(&profile_style_path, &style_css)?;
        write_style_to_path(&self.style_path, &style_css)?;

        let raw_json = serde_json::to_string_pretty(&config_value)?;
        Ok(self.build_snapshot(config_value, raw_json, style_css, Some(active_id)))
    }

    pub fn list_profiles(&mut self) -> Result<WaybarProfileListResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;
        let profiles = self.collect_profile_summaries();
        Ok(WaybarProfileListResponse { profiles })
    }

    pub fn create_profile(
        &mut self,
        name: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let trimmed = name.trim();
        if trimmed.is_empty() {
            return Err(WaybarConfigError::InvalidProfileName);
        }

        if self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.name.eq_ignore_ascii_case(trimmed))
        {
            return Err(WaybarConfigError::ProfileExists(trimmed.to_string()));
        }

        let base_slug = slugify_name(trimmed).ok_or(WaybarConfigError::InvalidProfileName)?;
        let mut candidate = base_slug.clone();
        let mut counter = 2u32;
        while self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.id == candidate)
        {
            candidate = format!("{base_slug}-{counter}");
            counter += 1;
        }

        let record = WaybarProfileRecord {
            id: candidate.clone(),
            name: trimmed.to_string(),
            is_default: false,
        };
        self.manifest.profiles.push(record);
        self.manifest.active_profile_id = Some(candidate.clone());

        let value = default_root_value();
        let style_css = default_style_css();
        let profile_path = self.profile_config_path(&candidate);
        let profile_style_path = self.profile_style_path(&candidate);
        write_value_to_path(&profile_path, &value)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&profile_style_path, &style_css)?;
        write_style_to_path(&self.style_path, &style_css)?;
        let raw_json = serde_json::to_string_pretty(&value)?;

        self.persist_manifest()?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(candidate.clone()));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    pub fn select_profile(
        &mut self,
        profile_id: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        if !self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.id == profile_id)
        {
            return Err(WaybarConfigError::ProfileNotFound(profile_id.to_string()));
        }

        let (value, raw_json) = self.load_profile_value(profile_id)?;
        let style_css = self.load_profile_style(profile_id)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)?;
        self.manifest.active_profile_id = Some(profile_id.to_string());
        self.persist_manifest()?;

        let snapshot =
            self.build_snapshot(value, raw_json, style_css, Some(profile_id.to_string()));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    pub fn delete_profile(
        &mut self,
        profile_id: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let position = self
            .manifest
            .profiles
            .iter()
            .position(|profile| profile.id == profile_id);

        let index =
            position.ok_or_else(|| WaybarConfigError::ProfileNotFound(profile_id.to_string()))?;
        if self.manifest.profiles[index].is_default {
            return Err(WaybarConfigError::CannotDeleteDefaultProfile);
        }

        let removed = self.manifest.profiles.remove(index);
        let profile_dir = self.profile_dir(&removed.id);
        if profile_dir.exists() {
            fs::remove_dir_all(&profile_dir)?;
        }

        let new_active = if self
            .manifest
            .active_profile_id
            .as_deref()
            .map(|id| id == removed.id)
            .unwrap_or(false)
        {
            self.manifest
                .profiles
                .iter()
                .find(|profile| profile.is_default)
                .or_else(|| self.manifest.profiles.first())
                .map(|profile| profile.id.clone())
        } else {
            self.manifest.active_profile_id.clone()
        };

        self.manifest.active_profile_id = new_active.clone();
        self.persist_manifest()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let (value, raw_json) = self.load_profile_value(&active_id)?;
        let style_css = self.load_profile_style(&active_id)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(active_id));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    fn ensure_manifest_integrity(&mut self) -> Result<(), WaybarConfigError> {
        let mut changed = false;

        if self.manifest.version == 0 {
            self.manifest.version = 1;
            changed = true;
        }

        if self.manifest.profiles.is_empty() {
            self.manifest = WaybarProfileManifest::default();
            changed = true;
        }

        if !self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.is_default)
        {
            self.manifest.profiles.insert(
                0,
                WaybarProfileRecord {
                    id: DEFAULT_PROFILE_ID.to_string(),
                    name: DEFAULT_PROFILE_NAME.to_string(),
                    is_default: true,
                },
            );
            changed = true;
        }

        if self.manifest.active_profile_id.is_none() {
            if let Some(default_profile) = self
                .manifest
                .profiles
                .iter()
                .find(|profile| profile.is_default)
            {
                self.manifest.active_profile_id = Some(default_profile.id.clone());
            } else if let Some(first_profile) = self.manifest.profiles.first() {
                self.manifest.active_profile_id = Some(first_profile.id.clone());
            }
            changed = true;
        }

        for profile in &self.manifest.profiles {
            self.ensure_profile_dir(&profile.id)?;
            let profile_path = self.profile_config_path(&profile.id);
            let profile_style_path = self.profile_style_path(&profile.id);
            if !profile_path.exists() {
                let value = default_root_value();
                write_value_to_path(&profile_path, &value)?;
                changed = true;
            }
            if !profile_style_path.exists() {
                let style_css = default_style_css();
                write_style_to_path(&profile_style_path, &style_css)?;
                changed = true;
            }
        }

        if !self.manifest_path.exists() || changed {
            self.persist_manifest()?;
        }

        if let Some(active_id) = self.manifest.active_profile_id.clone() {
            self.sync_profile_to_live(&active_id)?;
        }

        Ok(())
    }

    fn collect_profile_summaries(&self) -> Vec<WaybarProfileSummary> {
        let active_id = self.manifest.active_profile_id.as_deref();
        self.manifest
            .profiles
            .iter()
            .map(|profile| WaybarProfileSummary {
                id: profile.id.clone(),
                name: profile.name.clone(),
                is_default: profile.is_default,
                is_active: active_id == Some(profile.id.as_str()),
                is_protected: profile.is_default,
            })
            .collect()
    }

    fn profile_dir(&self, profile_id: &str) -> PathBuf {
        let mut dir = self.profiles_dir.clone();
        dir.push(profile_id);
        dir
    }

    fn profile_config_path(&self, profile_id: &str) -> PathBuf {
        let mut path = self.profile_dir(profile_id);
        path.push(PROFILE_CONFIG_FILE_NAME);
        path
    }

    fn profile_style_path(&self, profile_id: &str) -> PathBuf {
        let mut path = self.profile_dir(profile_id);
        path.push(PROFILE_STYLE_FILE_NAME);
        path
    }

    fn ensure_profile_dir(&self, profile_id: &str) -> Result<(), WaybarConfigError> {
        let dir = self.profile_dir(profile_id);
        if !dir.exists() {
            fs::create_dir_all(&dir)?;
        }
        Ok(())
    }

    fn persist_manifest(&self) -> Result<(), WaybarConfigError> {
        if let Some(parent) = self.manifest_path.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)?;
            }
        }
        let data = serde_json::to_vec_pretty(&self.manifest)?;
        fs::write(&self.manifest_path, data)?;
        Ok(())
    }

    fn load_profile_value(&self, profile_id: &str) -> Result<(Value, String), WaybarConfigError> {
        let path = self.profile_config_path(profile_id);
        if !path.exists() {
            let value = default_root_value();
            write_value_to_path(&path, &value)?;
        }
        read_value_from_path(&path)
    }

    fn load_profile_style(&self, profile_id: &str) -> Result<String, WaybarConfigError> {
        let path = self.profile_style_path(profile_id);
        if !path.exists() {
            let style_css = default_style_css();
            write_style_to_path(&path, &style_css)?;
            return Ok(style_css);
        }
        fs::read_to_string(&path).map_err(WaybarConfigError::Io)
    }

    fn sync_profile_to_live(&self, profile_id: &str) -> Result<(), WaybarConfigError> {
        let config_path = self.profile_config_path(profile_id);
        let style_path = self.profile_style_path(profile_id);

        if !config_path.exists() {
            let value = default_root_value();
            write_value_to_path(&config_path, &value)?;
        }
        if !style_path.exists() {
            let style_css = default_style_css();
            write_style_to_path(&style_path, &style_css)?;
        }

        let (value, _) = read_value_from_path(&config_path)?;
        let style_css = fs::read_to_string(&style_path).map_err(WaybarConfigError::Io)?;

        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)
    }

    fn build_snapshot(
        &self,
        value: Value,
        raw_json: String,
        style_css: String,
        profile_id: Option<String>,
    ) -> WaybarConfigSnapshot {
        let mut root_map = match value {
            Value::Object(map) => map,
            _ => Map::new(),
        };

        let layout = WaybarLayout {
            left: take_string_array(root_map.remove("modules-left"), default_left_modules()),
            center: take_string_array(root_map.remove("modules-center"), default_center_modules()),
            right: take_string_array(root_map.remove("modules-right"), default_right_modules()),
            hidden: vec![],
        };

        let mut globals = WaybarGlobals::default();
        if let Some(layer) = root_map
            .remove("layer")
            .and_then(|v| v.as_str().map(|s| s.to_string()))
        {
            globals.layer = layer;
        }
        if let Some(position) = root_map
            .remove("position")
            .and_then(|v| v.as_str().map(|s| s.to_string()))
        {
            globals.position = position;
        }

        if let Some(height) = root_map.remove("height").and_then(|v| v.as_f64()) {
            globals.height = height;
        }

        if let Some(spacing) = root_map.remove("spacing").and_then(|v| v.as_f64()) {
            globals.spacing = spacing;
        }

        if let Some(Value::Object(omarchist)) = root_map.get_mut("_omarchist") {
            if let Some(Value::Object(globals_obj)) = omarchist.remove("globals") {
                if let Some(height) = globals_obj.get("height").and_then(|v| v.as_f64()) {
                    globals.height = height;
                }
                if let Some(background) = globals_obj.get("background").and_then(|v| v.as_str()) {
                    globals.background = background.to_string();
                }
                if let Some(foreground) = globals_obj.get("foreground").and_then(|v| v.as_str()) {
                    globals.foreground = foreground.to_string();
                }
            }
            if omarchist.is_empty() {
                root_map.remove("_omarchist");
            }
        }

        let mut modules = default_modules_map();
        for key in KNOWN_MODULE_KEYS {
            if let Some(value) = root_map.remove(*key) {
                modules.insert((*key).to_string(), value);
            }
        }

        let seen: HashSet<String> = layout
            .left
            .iter()
            .chain(layout.center.iter())
            .chain(layout.right.iter())
            .cloned()
            .collect();
        let mut hidden = Vec::new();
        for key in KNOWN_MODULE_KEYS {
            if !seen.contains(*key) {
                hidden.push((*key).to_string());
            }
        }

        WaybarConfigSnapshot {
            layout: WaybarLayout {
                left: dedupe(layout.left),
                center: dedupe(layout.center),
                right: dedupe(layout.right),
                hidden,
            },
            globals,
            modules,
            passthrough: Value::Object(root_map),
            raw_json,
            profile_id,
            style_css,
        }
    }
}

fn write_value_to_path(path: &Path, value: &Value) -> Result<(), WaybarConfigError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let prettified = serde_json::to_string_pretty(value)?;
    let mut buffer = String::new();
    buffer.push_str(CONFIG_HEADER);
    buffer.push('\n');
    buffer.push_str(&prettified);
    buffer.push('\n');

    let mut file = fs::File::create(path)?;
    file.write_all(buffer.as_bytes())?;
    file.flush()?;
    Ok(())
}

fn write_style_to_path(path: &Path, style_css: &str) -> Result<(), WaybarConfigError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let mut buffer = String::new();
    buffer.push_str(STYLE_HEADER);
    buffer.push('\n');
    buffer.push_str(style_css);
    if !style_css.ends_with('\n') {
        buffer.push('\n');
    }

    let mut file = fs::File::create(path)?;
    file.write_all(buffer.as_bytes())?;
    file.flush()?;
    Ok(())
}

fn read_value_from_path(path: &Path) -> Result<(Value, String), WaybarConfigError> {
    let contents = fs::read_to_string(path)?;
    let mut reader = StripComments::new(contents.as_bytes());
    let value: Value = serde_json::from_reader(&mut reader)
        .map_err(|err| WaybarConfigError::Parse(err.to_string()))?;
    let raw_json = serde_json::to_string_pretty(&value)?;
    Ok((value, raw_json))
}

fn slugify_name(name: &str) -> Option<String> {
    let mut output = String::new();
    let mut last_was_dash = false;

    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            output.push(ch.to_ascii_lowercase());
            last_was_dash = false;
        } else if !output.is_empty() && !last_was_dash {
            output.push('-');
            last_was_dash = true;
        }
    }

    let slug = output.trim_matches('-').to_string();
    if slug.is_empty() {
        None
    } else {
        Some(slug)
    }
}

fn dedupe(list: Vec<String>) -> Vec<String> {
    let mut seen = HashSet::new();
    list.into_iter()
        .filter(|item| seen.insert(item.clone()))
        .collect()
}

fn unique_ordered(list: Vec<String>, seen: &mut HashSet<String>) -> Vec<String> {
    let mut result = Vec::new();
    for item in list {
        if seen.insert(item.clone()) {
            result.push(item);
        }
    }
    result
}

fn number_from_f64(value: f64, fallback: f64) -> serde_json::Number {
    serde_json::Number::from_f64(value)
        .or_else(|| serde_json::Number::from_f64(fallback))
        .unwrap()
}

fn take_string_array(value: Option<Value>, fallback: Vec<String>) -> Vec<String> {
    match value {
        Some(Value::Array(items)) => items
            .into_iter()
            .filter_map(|entry| entry.as_str().map(|s| s.to_string()))
            .collect(),
        _ => fallback,
    }
}

fn default_left_modules() -> Vec<String> {
    vec![
        "custom/omarchy".to_string(),
        "hyprland/workspaces".to_string(),
    ]
}

fn default_center_modules() -> Vec<String> {
    vec![
        "clock".to_string(),
        "custom/update".to_string(),
        "custom/screenrecording-indicator".to_string(),
    ]
}

fn default_right_modules() -> Vec<String> {
    vec![
        "group/tray-expander".to_string(),
        "bluetooth".to_string(),
        "network".to_string(),
        "pulseaudio".to_string(),
        "cpu".to_string(),
        "battery".to_string(),
    ]
}

fn default_modules_map() -> BTreeMap<String, Value> {
    let mut map = BTreeMap::new();
    map.insert(
        "custom/omarchy".to_string(),
        json!({
            "format": "<span font='omarchy'>\u{e900}</span>",
            "on-click": "omarchy-menu",
            "tooltip-format": "Omarchy Menu\n\nSuper + Alt + Space"
        }),
    );
    map.insert(
        "clock".to_string(),
        json!({
            "format": "{:L%A %H:%M}",
            "format-alt": "{:L%d %B W%V %Y}",
            "tooltip": false,
            "on-click-right": "omarchy-cmd-tzupdate"
        }),
    );
    map.insert(
        "custom/update".to_string(),
        json!({
            "format": "",
            "exec": "omarchy-update-available",
            "on-click": "omarchy-launch-floating-terminal-with-presentation omarchy-update",
            "tooltip-format": "Omarchy update available",
            "signal": 7,
            "interval": 3600
        }),
    );
    map.insert(
        "custom/screenrecording-indicator".to_string(),
        json!({
            "on-click": "omarchy-cmd-screenrecord",
            "exec": "$OMARCHY_PATH/default/waybar/indicators/screen-recording.sh",
            "signal": 8,
            "return-type": "json"
        }),
    );
    map.insert(
        "hyprland/workspaces".to_string(),
        json!({
            "on-click": "activate",
            "format": "{icon}",
            "format-icons": {
                "default": "",
                "1": "1",
                "2": "2",
                "3": "3",
                "4": "4",
                "5": "5",
                "6": "6",
                "7": "7",
                "8": "8",
                "9": "9",
                "active": "󱓻"
            },
            "persistent-workspaces": {
                "1": [],
                "2": [],
                "3": [],
                "4": [],
                "5": []
            }
        }),
    );
    map.insert(
        "hyprland/window".to_string(),
        json!({
            "format": "{title}",
            "max-length": 50
        }),
    );
    map.insert(
        "group/tray-expander".to_string(),
        json!({
            "orientation": "inherit",
            "drawer": {
                "transition-duration": 600,
                "children-class": "tray-group-item"
            },
            "modules": ["custom/expand-icon", "tray"]
        }),
    );
    map.insert(
        "custom/expand-icon".to_string(),
        json!({
            "format": " ",
            "tooltip": false
        }),
    );
    map.insert(
        "tray".to_string(),
        json!({
            "icon-size": 12,
            "spacing": 12
        }),
    );
    map.insert(
        "bluetooth".to_string(),
        json!({
            "format": "",
            "format-disabled": "󰂲",
            "format-connected": "",
            "tooltip-format": "Devices connected: {num_connections}",
            "on-click": "blueberry"
        }),
    );
    map.insert(
        "network".to_string(),
        json!({
            "format-icons": ["󰤯", "󰤟", "󰤢", "󰤥", "󰤨"],
            "format": "{icon}",
            "format-wifi": "{icon}",
            "format-ethernet": "󰀂",
            "format-disconnected": "󰤮",
            "tooltip-format-wifi": "{essid} ({frequency} GHz)\n⇣{bandwidthDownBytes}  ⇡{bandwidthUpBytes}",
            "tooltip-format-ethernet": "⇣{bandwidthDownBytes}  ⇡{bandwidthUpBytes}",
            "tooltip-format-disconnected": "Disconnected",
            "interval": 3,
            "spacing": 1,
            "on-click": "omarchy-launch-wifi"
        }),
    );
    map.insert(
        "pulseaudio".to_string(),
        json!({
            "format": "{icon}",
            "on-click": "$TERMINAL --class=Wiremix -e wiremix",
            "on-click-right": "pamixer -t",
            "tooltip-format": "Playing at {volume}%",
            "scroll-step": 5,
            "format-muted": "",
            "format-icons": {
                "default": ["", "", ""]
            }
        }),
    );
    map.insert(
        "cpu".to_string(),
        json!({
            "interval": 5,
            "format": "󰍛",
            "on-click": "$TERMINAL -e btop"
        }),
    );
    map.insert(
        "battery".to_string(),
        json!({
            "format": "{capacity}% {icon}",
            "format-discharging": "{icon}",
            "format-charging": "{icon}",
            "format-plugged": "",
            "format-icons": {
                "charging": ["󰢜", "󰂆", "󰂇", "󰂈", "󰢝", "󰂉", "󰢞", "󰂊", "󰂋", "󰂅"],
                "default": ["󰁺", "󰁻", "󰁼", "󰁽", "󰁾", "󰁿", "󰂀", "󰂁", "󰂂", "󰁹"]
            },
            "format-full": "󰂅",
            "tooltip-format-discharging": "{power:>1.0f}W↓ {capacity}%",
            "tooltip-format-charging": "{power:>1.0f}W↑ {capacity}%",
            "interval": 5,
            "on-click": "omarchy-menu power",
            "states": {
                "warning": 20,
                "critical": 10
            }
        }),
    );
    map
}

fn default_root_value() -> Value {
    let mut map = Map::new();
    let global_defaults = WaybarGlobals::default();
    map.insert("reload_style_on_change".to_string(), Value::Bool(true));
    map.insert("layer".to_string(), Value::String("top".to_string()));
    map.insert("position".to_string(), Value::String("top".to_string()));
    map.insert(
        "height".to_string(),
        Value::Number(number_from_f64(global_defaults.height, 26.0)),
    );
    map.insert(
        "spacing".to_string(),
        Value::Number(number_from_f64(global_defaults.spacing, 0.0)),
    );
    map.insert(
        "modules-left".to_string(),
        Value::Array(
            default_left_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );
    map.insert(
        "modules-center".to_string(),
        Value::Array(
            default_center_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );
    map.insert(
        "modules-right".to_string(),
        Value::Array(
            default_right_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );

    let defaults = default_modules_map();
    for key in [
        "custom/omarchy",
        "hyprland/workspaces",
        "clock",
        "custom/update",
        "custom/screenrecording-indicator",
        "group/tray-expander",
        "custom/expand-icon",
        "tray",
        "bluetooth",
        "network",
        "pulseaudio",
        "cpu",
        "battery",
    ] {
        if let Some(value) = defaults.get(key).cloned() {
            map.insert(key.to_string(), value);
        }
    }

    Value::Object(map)
}

fn default_style_css() -> String {
    r#"@import "../omarchy/current/theme/waybar.css";

* {
  background-color: @background;
  color: @foreground;

  border: none;
  border-radius: 0;
  min-height: 0;
  font-family: CaskaydiaMono Nerd Font;
  font-size: 12px;
}

.modules-left {
  margin-left: 8px;
}

.modules-right {
  margin-right: 8px;
}

#workspaces button {
  all: initial;
  padding: 0 6px;
  margin: 0 1.5px;
  min-width: 9px;
}

#workspaces button.empty {
  opacity: 0.5;
}

#tray,
#cpu,
#battery,
#network,
#bluetooth,
#pulseaudio,
#custom-omarchy,
#custom-screenrecording-indicator,
#custom-update {
  min-width: 12px;
  margin: 0 7.5px;
}

#custom-expand-icon {
  margin-right: 7px;
}

tooltip {
  padding: 2px;
}

#custom-update {
  font-size: 10px;
}

#clock {
  margin-left: 8.75px;
}

.hidden {
  opacity: 0;
}

#custom-screenrecording-indicator {
  min-width: 12px;
  margin-left: 8.75px;
  font-size: 10px;
}

#custom-screenrecording-indicator.active {
  color: #a55555;
}
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn default_config_contains_known_modules() {
        let value = default_root_value();
        let service = WaybarConfigService {
            config_path: PathBuf::from("/tmp/waybar.jsonc"),
            style_path: PathBuf::from("/tmp/waybar.css"),
            profiles_dir: PathBuf::from("/tmp"),
            manifest_path: PathBuf::from("/tmp/manifest.json"),
            manifest: WaybarProfileManifest::default(),
        };
        let snapshot = service.build_snapshot(
            value.clone(),
            serde_json::to_string_pretty(&value).unwrap(),
            default_style_css(),
            Some(DEFAULT_PROFILE_ID.to_string()),
        );
        assert_eq!(snapshot.layout.left.len(), 2);
        assert_eq!(snapshot.layout.center.len(), 3);
        assert_eq!(snapshot.layout.right.len(), 6);
        assert!(snapshot.modules.contains_key("custom/omarchy"));
    }

    #[test]
    fn default_style_css_contains_expected_content() {
        let css = default_style_css();
        assert!(css.contains("@import"));
        assert!(css.contains("@background"));
        assert!(css.contains("@foreground"));
        assert!(css.contains("#workspaces"));
        assert!(css.contains("#clock"));
        assert!(css.contains("CaskaydiaMono Nerd Font"));
    }

    #[test]
    fn snapshot_includes_style_css() {
        let value = default_root_value();
        let service = WaybarConfigService {
            config_path: PathBuf::from("/tmp/waybar.jsonc"),
            style_path: PathBuf::from("/tmp/waybar.css"),
            profiles_dir: PathBuf::from("/tmp"),
            manifest_path: PathBuf::from("/tmp/manifest.json"),
            manifest: WaybarProfileManifest::default(),
        };
        let css = "/* test css */";
        let snapshot = service.build_snapshot(
            value.clone(),
            serde_json::to_string_pretty(&value).unwrap(),
            css.to_string(),
            Some(DEFAULT_PROFILE_ID.to_string()),
        );
        assert_eq!(snapshot.style_css, css);
    }
}
