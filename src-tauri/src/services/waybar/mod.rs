use dirs::home_dir;
use json_comments::StripComments;
use serde::{Deserialize, Serialize};
use serde_json::{json, Map, Value};
use std::collections::{BTreeMap, HashSet};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

const OMARCHIST_WAYBAR_SUBDIR: &str = ".config/omarchist/waybar";
const WAYBAR_PROFILES_DIR_NAME: &str = "profiles";
const WAYBAR_MANIFEST_FILE_NAME: &str = "manifest.json";
const PROFILE_CONFIG_FILE_NAME: &str = "config.jsonc";
const PROFILE_STYLE_FILE_NAME: &str = "style.css";
const DEFAULT_PROFILE_ID: &str = "omarchy-default";
const DEFAULT_PROFILE_NAME: &str = "Omarchy Default";

const KNOWN_MODULE_KEYS: &[&str] = &[
    "custom/omarchy",
    "hyprland/workspaces",
    "hyprland/window",
    "clock",
    "custom/update",
    "custom/screenrecording-indicator",
    "group/tray-expander",
    "custom/expand-icon",
    "tray",
    "bluetooth",
    "network",
    "pulseaudio",
    "cpu",
    "memory",
    "battery",
];

const CONFIG_HEADER: &str = "// Generated by Omarchist Waybar editor\n// Manual edits for unsupported fields will be preserved.\n";

const STYLE_HEADER: &str = "/* Generated by Omarchist Waybar editor */\n/* Manual edits will be preserved when possible */\n";

#[derive(Debug, thiserror::Error)]
pub enum WaybarConfigError {
    #[error("Unable to resolve home directory")]
    HomeDirNotFound,
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Failed to parse Waybar config: {0}")]
    Parse(String),
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
    #[error("Waybar profile already exists: {0}")]
    ProfileExists(String),
    #[error("Waybar profile not found: {0}")]
    ProfileNotFound(String),
    #[error("Waybar profile name is invalid")]
    InvalidProfileName,
    #[error("The default Waybar profile cannot be deleted")]
    CannotDeleteDefaultProfile,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct WaybarLayout {
    pub left: Vec<String>,
    pub center: Vec<String>,
    pub right: Vec<String>,
    pub hidden: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WaybarGlobals {
    pub layer: String,
    pub position: String,
    pub height: f64,
    pub spacing: f64,
    pub background: String,
    pub foreground: String,
    #[serde(default)]
    pub left_margin: f64,
    #[serde(default)]
    pub left_padding: f64,
    #[serde(default)]
    pub left_background: String,
    #[serde(default)]
    pub center_margin: f64,
    #[serde(default)]
    pub center_padding: f64,
    #[serde(default)]
    pub center_background: String,
    #[serde(default)]
    pub right_margin: f64,
    #[serde(default)]
    pub right_padding: f64,
    #[serde(default)]
    pub right_background: String,
}

impl Default for WaybarGlobals {
    fn default() -> Self {
        Self {
            layer: "top".to_string(),
            position: "top".to_string(),
            height: 26.0,
            spacing: 0.0,
            background: "#1e1e1e".to_string(),
            foreground: "#d4d4d8".to_string(),
            left_margin: 8.0,
            left_padding: 0.0,
            left_background: String::new(),
            center_margin: 0.0,
            center_padding: 0.0,
            center_background: String::new(),
            right_margin: 8.0,
            right_padding: 0.0,
            right_background: String::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct WaybarProfileRecord {
    id: String,
    name: String,
    is_default: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct WaybarProfileManifest {
    version: u32,
    active_profile_id: Option<String>,
    profiles: Vec<WaybarProfileRecord>,
}

impl Default for WaybarProfileManifest {
    fn default() -> Self {
        Self {
            version: 1,
            active_profile_id: Some(DEFAULT_PROFILE_ID.to_string()),
            profiles: vec![WaybarProfileRecord {
                id: DEFAULT_PROFILE_ID.to_string(),
                name: DEFAULT_PROFILE_NAME.to_string(),
                is_default: true,
            }],
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileSummary {
    pub id: String,
    pub name: String,
    pub is_default: bool,
    pub is_active: bool,
    pub is_protected: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarConfigSnapshot {
    pub layout: WaybarLayout,
    pub globals: WaybarGlobals,
    pub modules: BTreeMap<String, Value>,
    pub passthrough: Value,
    pub raw_json: String,
    pub profile_id: Option<String>,
    pub style_css: String,
}

impl Default for WaybarConfigSnapshot {
    fn default() -> Self {
        Self {
            layout: WaybarLayout::default(),
            globals: WaybarGlobals::default(),
            modules: default_modules_map(),
            passthrough: json!({
                "reload_style_on_change": true
            }),
            raw_json: String::new(),
            profile_id: None,
            style_css: default_style_css(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileListResponse {
    pub profiles: Vec<WaybarProfileSummary>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaybarProfileChangeResponse {
    pub snapshot: WaybarConfigSnapshot,
    pub profiles: Vec<WaybarProfileSummary>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SaveWaybarConfigPayload {
    pub layout: WaybarLayout,
    pub globals: WaybarGlobals,
    pub modules: BTreeMap<String, Value>,
    pub passthrough: Value,
    #[serde(default)]
    pub style_css: String,
    #[serde(default)]
    pub module_styles: BTreeMap<String, Value>,
}

pub struct WaybarConfigService {
    config_path: PathBuf,
    style_path: PathBuf,
    profiles_dir: PathBuf,
    manifest_path: PathBuf,
    manifest: WaybarProfileManifest,
}

impl WaybarConfigService {
    pub fn new() -> Result<Self, WaybarConfigError> {
        let home = home_dir().ok_or(WaybarConfigError::HomeDirNotFound)?;

        let mut config_path = home.clone();
        config_path.push(".config/waybar/config.jsonc");

        let mut style_path = home.clone();
        style_path.push(".config/waybar/style.css");

        let mut omarchist_dir = home.clone();
        omarchist_dir.push(OMARCHIST_WAYBAR_SUBDIR);

        let mut profiles_dir = omarchist_dir.clone();
        profiles_dir.push(WAYBAR_PROFILES_DIR_NAME);

        let mut manifest_path = omarchist_dir.clone();
        manifest_path.push(WAYBAR_MANIFEST_FILE_NAME);

        if !profiles_dir.exists() {
            fs::create_dir_all(&profiles_dir)?;
        }

        let manifest = if manifest_path.exists() {
            let contents = fs::read_to_string(&manifest_path)?;
            serde_json::from_str::<WaybarProfileManifest>(&contents).unwrap_or_default()
        } else {
            WaybarProfileManifest::default()
        };

        let mut service = Self {
            config_path,
            style_path,
            profiles_dir,
            manifest_path,
            manifest,
        };

        service.ensure_manifest_integrity()?;
        Ok(service)
    }

    pub fn load_snapshot(&mut self) -> Result<WaybarConfigSnapshot, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let (value, raw_json) = self.load_profile_value(&active_id)?;
        let style_css = self.load_profile_style(&active_id)?;
        self.sync_profile_to_live(&active_id)?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(active_id));
        Ok(snapshot)
    }

    pub fn save_snapshot(
        &mut self,
        payload: &SaveWaybarConfigPayload,
    ) -> Result<WaybarConfigSnapshot, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let global_defaults = WaybarGlobals::default();

        let mut seen = HashSet::new();
        let left = unique_ordered(payload.layout.left.clone(), &mut seen);
        let center = unique_ordered(payload.layout.center.clone(), &mut seen);
        let right = unique_ordered(payload.layout.right.clone(), &mut seen);

        let mut root_map = match payload.passthrough.clone() {
            Value::Object(map) => map,
            _ => Map::new(),
        };

        root_map.insert(
            "layer".to_string(),
            Value::String(payload.globals.layer.clone()),
        );
        root_map.insert(
            "position".to_string(),
            Value::String(payload.globals.position.clone()),
        );
        root_map.insert(
            "spacing".to_string(),
            Value::Number(number_from_f64(
                payload.globals.spacing,
                global_defaults.spacing,
            )),
        );
        root_map.insert(
            "modules-left".to_string(),
            Value::Array(left.iter().map(|id| Value::String(id.clone())).collect()),
        );
        root_map.insert(
            "modules-center".to_string(),
            Value::Array(center.iter().map(|id| Value::String(id.clone())).collect()),
        );
        root_map.insert(
            "modules-right".to_string(),
            Value::Array(right.iter().map(|id| Value::String(id.clone())).collect()),
        );

        root_map.insert(
            "height".to_string(),
            Value::Number(number_from_f64(
                payload.globals.height,
                global_defaults.height,
            )),
        );

        // Preserve order of module definitions based on their appearance in layout
        // First collect all unique module IDs from layout in order
        let mut ordered_module_keys: Vec<String> = Vec::new();
        let mut seen_keys = HashSet::new();

        // Add modules in the order they appear in the layout (left, center, right)
        for module_id in left
            .iter()
            .chain(center.iter())
            .chain(right.iter())
        {
            if seen_keys.insert(module_id.clone()) {
                ordered_module_keys.push(module_id.clone());
            }
        }

        // Add any remaining known modules that aren't in the layout
        for key in KNOWN_MODULE_KEYS {
            if seen_keys.insert((*key).to_string()) {
                ordered_module_keys.push((*key).to_string());
            }
        }

        // Add module definitions in the preserved order
        let defaults = default_modules_map();
        for key in &ordered_module_keys {
            let value = payload.modules.get(key).cloned().unwrap_or_else(|| {
                defaults
                    .get(key)
                    .cloned()
                    .unwrap_or(Value::Object(Map::new()))
            });
            root_map.insert(key.clone(), value);
        }

        // Store module styles in _omarchist section if present
        if !payload.module_styles.is_empty() {
            let mut omarchist = Map::new();
            omarchist.insert(
                "moduleStyles".to_string(),
                Value::Object(
                    payload
                        .module_styles
                        .iter()
                        .map(|(k, v)| (k.clone(), v.clone()))
                        .collect(),
                ),
            );
            root_map.insert("_omarchist".to_string(), Value::Object(omarchist));
        } else {
            root_map.remove("_omarchist");
        }

        let config_value = Value::Object(root_map);
        let profile_path = self.profile_config_path(&active_id);
        write_value_to_path(&profile_path, &config_value)?;
        write_value_to_path(&self.config_path, &config_value)?;

        // Handle CSS styling - use the CSS provided by the frontend
        // If no CSS is provided in the payload (backward compatibility), fallback to generation
        let style_css = if !payload.style_css.is_empty() {
            payload.style_css.clone()
        } else {
            generate_style_css(&payload.globals, &payload.module_styles)
        };

        let profile_style_path = self.profile_style_path(&active_id);
        write_style_to_path(&profile_style_path, &style_css)?;
        write_style_to_path(&self.style_path, &style_css)?;

        let raw_json = serde_json::to_string_pretty(&config_value)?;
        Ok(self.build_snapshot(config_value, raw_json, style_css, Some(active_id)))
    }

    pub fn list_profiles(&mut self) -> Result<WaybarProfileListResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;
        let profiles = self.collect_profile_summaries();
        Ok(WaybarProfileListResponse { profiles })
    }

    pub fn create_profile(
        &mut self,
        name: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let trimmed = name.trim();
        if trimmed.is_empty() {
            return Err(WaybarConfigError::InvalidProfileName);
        }

        if self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.name.eq_ignore_ascii_case(trimmed))
        {
            return Err(WaybarConfigError::ProfileExists(trimmed.to_string()));
        }

        let base_slug = slugify_name(trimmed).ok_or(WaybarConfigError::InvalidProfileName)?;
        let mut candidate = base_slug.clone();
        let mut counter = 2u32;
        while self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.id == candidate)
        {
            candidate = format!("{base_slug}-{counter}");
            counter += 1;
        }

        let record = WaybarProfileRecord {
            id: candidate.clone(),
            name: trimmed.to_string(),
            is_default: false,
        };
        self.manifest.profiles.push(record);
        self.manifest.active_profile_id = Some(candidate.clone());

        let value = default_root_value();
        let globals = WaybarGlobals::default();
        let style_css = generate_style_css(&globals, &BTreeMap::new());
        let profile_path = self.profile_config_path(&candidate);
        let profile_style_path = self.profile_style_path(&candidate);
        write_value_to_path(&profile_path, &value)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&profile_style_path, &style_css)?;
        write_style_to_path(&self.style_path, &style_css)?;
        let raw_json = serde_json::to_string_pretty(&value)?;

        self.persist_manifest()?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(candidate.clone()));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    pub fn select_profile(
        &mut self,
        profile_id: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        if !self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.id == profile_id)
        {
            return Err(WaybarConfigError::ProfileNotFound(profile_id.to_string()));
        }

        let (value, raw_json) = self.load_profile_value(profile_id)?;
        let style_css = self.load_profile_style(profile_id)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)?;
        self.manifest.active_profile_id = Some(profile_id.to_string());
        self.persist_manifest()?;

        let snapshot =
            self.build_snapshot(value, raw_json, style_css, Some(profile_id.to_string()));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    pub fn delete_profile(
        &mut self,
        profile_id: &str,
    ) -> Result<WaybarProfileChangeResponse, WaybarConfigError> {
        self.ensure_manifest_integrity()?;

        let position = self
            .manifest
            .profiles
            .iter()
            .position(|profile| profile.id == profile_id);

        let index =
            position.ok_or_else(|| WaybarConfigError::ProfileNotFound(profile_id.to_string()))?;
        if self.manifest.profiles[index].is_default {
            return Err(WaybarConfigError::CannotDeleteDefaultProfile);
        }

        let removed = self.manifest.profiles.remove(index);
        let profile_dir = self.profile_dir(&removed.id);
        if profile_dir.exists() {
            fs::remove_dir_all(&profile_dir)?;
        }

        let new_active = if self
            .manifest
            .active_profile_id
            .as_deref()
            .map(|id| id == removed.id)
            .unwrap_or(false)
        {
            self.manifest
                .profiles
                .iter()
                .find(|profile| profile.is_default)
                .or_else(|| self.manifest.profiles.first())
                .map(|profile| profile.id.clone())
        } else {
            self.manifest.active_profile_id.clone()
        };

        self.manifest.active_profile_id = new_active.clone();
        self.persist_manifest()?;

        let active_id = self
            .manifest
            .active_profile_id
            .clone()
            .unwrap_or_else(|| DEFAULT_PROFILE_ID.to_string());

        let (value, raw_json) = self.load_profile_value(&active_id)?;
        let style_css = self.load_profile_style(&active_id)?;
        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)?;

        let snapshot = self.build_snapshot(value, raw_json, style_css, Some(active_id));
        let profiles = self.collect_profile_summaries();

        Ok(WaybarProfileChangeResponse { snapshot, profiles })
    }

    fn ensure_manifest_integrity(&mut self) -> Result<(), WaybarConfigError> {
        let mut changed = false;

        if self.manifest.version == 0 {
            self.manifest.version = 1;
            changed = true;
        }

        if self.manifest.profiles.is_empty() {
            self.manifest = WaybarProfileManifest::default();
            changed = true;
        }

        if !self
            .manifest
            .profiles
            .iter()
            .any(|profile| profile.is_default)
        {
            self.manifest.profiles.insert(
                0,
                WaybarProfileRecord {
                    id: DEFAULT_PROFILE_ID.to_string(),
                    name: DEFAULT_PROFILE_NAME.to_string(),
                    is_default: true,
                },
            );
            changed = true;
        }

        if self.manifest.active_profile_id.is_none() {
            if let Some(default_profile) = self
                .manifest
                .profiles
                .iter()
                .find(|profile| profile.is_default)
            {
                self.manifest.active_profile_id = Some(default_profile.id.clone());
            } else if let Some(first_profile) = self.manifest.profiles.first() {
                self.manifest.active_profile_id = Some(first_profile.id.clone());
            }
            changed = true;
        }

        for profile in &self.manifest.profiles {
            self.ensure_profile_dir(&profile.id)?;
            let profile_path = self.profile_config_path(&profile.id);
            let profile_style_path = self.profile_style_path(&profile.id);
            if !profile_path.exists() {
                let value = default_root_value();
                write_value_to_path(&profile_path, &value)?;
                changed = true;
            }
            if !profile_style_path.exists() {
                let style_css = default_style_css();
                write_style_to_path(&profile_style_path, &style_css)?;
                changed = true;
            }
        }

        if !self.manifest_path.exists() || changed {
            self.persist_manifest()?;
        }

        if let Some(active_id) = self.manifest.active_profile_id.clone() {
            self.sync_profile_to_live(&active_id)?;
        }

        Ok(())
    }

    fn collect_profile_summaries(&self) -> Vec<WaybarProfileSummary> {
        let active_id = self.manifest.active_profile_id.as_deref();
        self.manifest
            .profiles
            .iter()
            .map(|profile| WaybarProfileSummary {
                id: profile.id.clone(),
                name: profile.name.clone(),
                is_default: profile.is_default,
                is_active: active_id == Some(profile.id.as_str()),
                is_protected: profile.is_default,
            })
            .collect()
    }

    fn profile_dir(&self, profile_id: &str) -> PathBuf {
        let mut dir = self.profiles_dir.clone();
        dir.push(profile_id);
        dir
    }

    fn profile_config_path(&self, profile_id: &str) -> PathBuf {
        let mut path = self.profile_dir(profile_id);
        path.push(PROFILE_CONFIG_FILE_NAME);
        path
    }

    fn profile_style_path(&self, profile_id: &str) -> PathBuf {
        let mut path = self.profile_dir(profile_id);
        path.push(PROFILE_STYLE_FILE_NAME);
        path
    }

    fn ensure_profile_dir(&self, profile_id: &str) -> Result<(), WaybarConfigError> {
        let dir = self.profile_dir(profile_id);
        if !dir.exists() {
            fs::create_dir_all(&dir)?;
        }
        Ok(())
    }

    fn persist_manifest(&self) -> Result<(), WaybarConfigError> {
        if let Some(parent) = self.manifest_path.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)?;
            }
        }
        let data = serde_json::to_vec_pretty(&self.manifest)?;
        fs::write(&self.manifest_path, data)?;
        Ok(())
    }

    fn load_profile_value(&self, profile_id: &str) -> Result<(Value, String), WaybarConfigError> {
        let path = self.profile_config_path(profile_id);
        if !path.exists() {
            let value = default_root_value();
            write_value_to_path(&path, &value)?;
        }
        read_value_from_path(&path)
    }

    fn load_profile_style(&self, profile_id: &str) -> Result<String, WaybarConfigError> {
        let path = self.profile_style_path(profile_id);
        if !path.exists() {
            let style_css = default_style_css();
            write_style_to_path(&path, &style_css)?;
            return Ok(style_css);
        }
        fs::read_to_string(&path).map_err(WaybarConfigError::Io)
    }

    fn sync_profile_to_live(&self, profile_id: &str) -> Result<(), WaybarConfigError> {
        let config_path = self.profile_config_path(profile_id);
        let style_path = self.profile_style_path(profile_id);

        if !config_path.exists() {
            let value = default_root_value();
            write_value_to_path(&config_path, &value)?;
        }
        if !style_path.exists() {
            let style_css = default_style_css();
            write_style_to_path(&style_path, &style_css)?;
        }

        let (value, _) = read_value_from_path(&config_path)?;
        let style_css = fs::read_to_string(&style_path).map_err(WaybarConfigError::Io)?;

        write_value_to_path(&self.config_path, &value)?;
        write_style_to_path(&self.style_path, &style_css)
    }

    fn build_snapshot(
        &self,
        value: Value,
        raw_json: String,
        style_css: String,
        profile_id: Option<String>,
    ) -> WaybarConfigSnapshot {
        let mut root_map = match value {
            Value::Object(map) => map,
            _ => Map::new(),
        };

        let layout = WaybarLayout {
            left: take_string_array(root_map.remove("modules-left"), default_left_modules()),
            center: take_string_array(root_map.remove("modules-center"), default_center_modules()),
            right: take_string_array(root_map.remove("modules-right"), default_right_modules()),
            hidden: vec![],
        };

        let mut globals = WaybarGlobals::default();
        if let Some(layer) = root_map
            .remove("layer")
            .and_then(|v| v.as_str().map(|s| s.to_string()))
        {
            globals.layer = layer;
        }
        if let Some(position) = root_map
            .remove("position")
            .and_then(|v| v.as_str().map(|s| s.to_string()))
        {
            globals.position = position;
        }

        if let Some(height) = root_map.remove("height").and_then(|v| v.as_f64()) {
            globals.height = height;
        }

        if let Some(spacing) = root_map.remove("spacing").and_then(|v| v.as_f64()) {
            globals.spacing = spacing;
        }

        // Parse CSS to extract styling values
        globals = parse_globals_from_css(&style_css, globals);

        let mut modules = default_modules_map();
        for key in KNOWN_MODULE_KEYS {
            if let Some(value) = root_map.remove(*key) {
                modules.insert((*key).to_string(), value);
            }
        }

        let seen: HashSet<String> = layout
            .left
            .iter()
            .chain(layout.center.iter())
            .chain(layout.right.iter())
            .cloned()
            .collect();
        let mut hidden = Vec::new();
        for key in KNOWN_MODULE_KEYS {
            if !seen.contains(*key) {
                hidden.push((*key).to_string());
            }
        }

        WaybarConfigSnapshot {
            layout: WaybarLayout {
                left: dedupe(layout.left),
                center: dedupe(layout.center),
                right: dedupe(layout.right),
                hidden,
            },
            globals,
            modules,
            passthrough: Value::Object(root_map),
            raw_json,
            profile_id,
            style_css,
        }
    }
}

fn write_value_to_path(path: &Path, value: &Value) -> Result<(), WaybarConfigError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let prettified = serde_json::to_string_pretty(value)?;
    let mut buffer = String::new();
    buffer.push_str(CONFIG_HEADER);
    buffer.push('\n');
    buffer.push_str(&prettified);
    buffer.push('\n');

    let mut file = fs::File::create(path)?;
    file.write_all(buffer.as_bytes())?;
    file.flush()?;
    Ok(())
}

fn write_style_to_path(path: &Path, style_css: &str) -> Result<(), WaybarConfigError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let mut buffer = String::new();
    buffer.push_str(STYLE_HEADER);
    buffer.push('\n');
    buffer.push_str(style_css);
    if !style_css.ends_with('\n') {
        buffer.push('\n');
    }

    let mut file = fs::File::create(path)?;
    file.write_all(buffer.as_bytes())?;
    file.flush()?;
    Ok(())
}

fn read_value_from_path(path: &Path) -> Result<(Value, String), WaybarConfigError> {
    let contents = fs::read_to_string(path)?;
    let mut reader = StripComments::new(contents.as_bytes());
    let value: Value = serde_json::from_reader(&mut reader)
        .map_err(|err| WaybarConfigError::Parse(err.to_string()))?;
    let raw_json = serde_json::to_string_pretty(&value)?;
    Ok((value, raw_json))
}

fn slugify_name(name: &str) -> Option<String> {
    let mut output = String::new();
    let mut last_was_dash = false;

    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            output.push(ch.to_ascii_lowercase());
            last_was_dash = false;
        } else if !output.is_empty() && !last_was_dash {
            output.push('-');
            last_was_dash = true;
        }
    }

    let slug = output.trim_matches('-').to_string();
    if slug.is_empty() {
        None
    } else {
        Some(slug)
    }
}

fn dedupe(list: Vec<String>) -> Vec<String> {
    let mut seen = HashSet::new();
    list.into_iter()
        .filter(|item| seen.insert(item.clone()))
        .collect()
}

fn unique_ordered(list: Vec<String>, seen: &mut HashSet<String>) -> Vec<String> {
    let mut result = Vec::new();
    for item in list {
        if seen.insert(item.clone()) {
            result.push(item);
        }
    }
    result
}

fn number_from_f64(value: f64, fallback: f64) -> serde_json::Number {
    serde_json::Number::from_f64(value)
        .or_else(|| serde_json::Number::from_f64(fallback))
        .unwrap()
}

fn take_string_array(value: Option<Value>, fallback: Vec<String>) -> Vec<String> {
    match value {
        Some(Value::Array(items)) => items
            .into_iter()
            .filter_map(|entry| entry.as_str().map(|s| s.to_string()))
            .collect(),
        _ => fallback,
    }
}

fn default_left_modules() -> Vec<String> {
    vec![
        "custom/omarchy".to_string(),
        "hyprland/workspaces".to_string(),
    ]
}

fn default_center_modules() -> Vec<String> {
    vec![
        "clock".to_string(),
        "custom/update".to_string(),
        "custom/screenrecording-indicator".to_string(),
    ]
}

fn default_right_modules() -> Vec<String> {
    vec![
        "group/tray-expander".to_string(),
        "bluetooth".to_string(),
        "network".to_string(),
        "pulseaudio".to_string(),
        "cpu".to_string(),
        "battery".to_string(),
    ]
}

fn default_modules_map() -> BTreeMap<String, Value> {
    let mut map = BTreeMap::new();
    map.insert(
        "custom/omarchy".to_string(),
        json!({
            "format": "<span font='omarchy'>\u{e900}</span>",
            "on-click": "omarchy-menu",
            "tooltip-format": "Omarchy Menu\n\nSuper + Alt + Space"
        }),
    );
    map.insert(
        "clock".to_string(),
        json!({
            "format": "{:L%A %H:%M}",
            "format-alt": "{:L%d %B W%V %Y}",
            "tooltip": false,
            "on-click-right": "omarchy-cmd-tzupdate"
        }),
    );
    map.insert(
        "custom/update".to_string(),
        json!({
            "format": "",
            "exec": "omarchy-update-available",
            "on-click": "omarchy-launch-floating-terminal-with-presentation omarchy-update",
            "tooltip-format": "Omarchy update available",
            "signal": 7,
            "interval": 3600
        }),
    );
    map.insert(
        "custom/screenrecording-indicator".to_string(),
        json!({
            "on-click": "omarchy-cmd-screenrecord",
            "exec": "$OMARCHY_PATH/default/waybar/indicators/screen-recording.sh",
            "signal": 8,
            "return-type": "json"
        }),
    );
    map.insert(
        "hyprland/workspaces".to_string(),
        json!({
            "on-click": "activate",
            "format": "{icon}",
            "format-icons": {
                "default": "",
                "1": "1",
                "2": "2",
                "3": "3",
                "4": "4",
                "5": "5",
                "6": "6",
                "7": "7",
                "8": "8",
                "9": "9",
                "active": "󱓻"
            },
            "persistent-workspaces": {
                "1": [],
                "2": [],
                "3": [],
                "4": [],
                "5": []
            }
        }),
    );
    map.insert(
        "hyprland/window".to_string(),
        json!({
            "format": "{title}",
            "max-length": 50
        }),
    );
    map.insert(
        "group/tray-expander".to_string(),
        json!({
            "orientation": "inherit",
            "drawer": {
                "transition-duration": 600,
                "children-class": "tray-group-item"
            },
            "modules": ["custom/expand-icon", "tray"]
        }),
    );
    map.insert(
        "custom/expand-icon".to_string(),
        json!({
            "format": " ",
            "tooltip": false
        }),
    );
    map.insert(
        "tray".to_string(),
        json!({
            "icon-size": 12,
            "spacing": 12
        }),
    );
    map.insert(
        "bluetooth".to_string(),
        json!({
            "format": "",
            "format-disabled": "󰂲",
            "format-connected": "",
            "tooltip-format": "Devices connected: {num_connections}",
            "on-click": "blueberry"
        }),
    );
    map.insert(
        "network".to_string(),
        json!({
            "format-icons": ["󰤯", "󰤟", "󰤢", "󰤥", "󰤨"],
            "format": "{icon}",
            "format-wifi": "{icon}",
            "format-ethernet": "󰀂",
            "format-disconnected": "󰤮",
            "tooltip-format-wifi": "{essid} ({frequency} GHz)\n⇣{bandwidthDownBytes}  ⇡{bandwidthUpBytes}",
            "tooltip-format-ethernet": "⇣{bandwidthDownBytes}  ⇡{bandwidthUpBytes}",
            "tooltip-format-disconnected": "Disconnected",
            "interval": 3,
            "spacing": 1,
            "on-click": "omarchy-launch-wifi"
        }),
    );
    map.insert(
        "pulseaudio".to_string(),
        json!({
            "format": "{icon}",
            "on-click": "$TERMINAL --class=Wiremix -e wiremix",
            "on-click-right": "pamixer -t",
            "tooltip-format": "Playing at {volume}%",
            "scroll-step": 5,
            "format-muted": "",
            "format-icons": {
                "default": ["", "", ""]
            }
        }),
    );
    map.insert(
        "cpu".to_string(),
        json!({
            "interval": 5,
            "format": "󰍛",
            "on-click": "$TERMINAL -e btop"
        }),
    );
    map.insert(
        "memory".to_string(),
        json!({
            "interval": 30,
            "format": "{percentage}%",
            "tooltip": true,
            "tooltip-format": "Memory: {used:0.1f}GB / {total:0.1f}GB"
        }),
    );
    map.insert(
        "battery".to_string(),
        json!({
            "format": "{capacity}% {icon}",
            "format-discharging": "{icon}",
            "format-charging": "{icon}",
            "format-plugged": "",
            "format-icons": {
                "charging": ["󰢜", "󰂆", "󰂇", "󰂈", "󰢝", "󰂉", "󰢞", "󰂊", "󰂋", "󰂅"],
                "default": ["󰁺", "󰁻", "󰁼", "󰁽", "󰁾", "󰁿", "󰂀", "󰂁", "󰂂", "󰁹"]
            },
            "format-full": "󰂅",
            "tooltip-format-discharging": "{power:>1.0f}W↓ {capacity}%",
            "tooltip-format-charging": "{power:>1.0f}W↑ {capacity}%",
            "interval": 5,
            "on-click": "omarchy-menu power",
            "states": {
                "warning": 20,
                "critical": 10
            }
        }),
    );
    map
}

fn default_root_value() -> Value {
    let mut map = Map::new();
    let global_defaults = WaybarGlobals::default();
    map.insert("reload_style_on_change".to_string(), Value::Bool(true));
    map.insert("layer".to_string(), Value::String("top".to_string()));
    map.insert("position".to_string(), Value::String("top".to_string()));
    map.insert(
        "height".to_string(),
        Value::Number(number_from_f64(global_defaults.height, 26.0)),
    );
    map.insert(
        "spacing".to_string(),
        Value::Number(number_from_f64(global_defaults.spacing, 0.0)),
    );
    map.insert(
        "modules-left".to_string(),
        Value::Array(
            default_left_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );
    map.insert(
        "modules-center".to_string(),
        Value::Array(
            default_center_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );
    map.insert(
        "modules-right".to_string(),
        Value::Array(
            default_right_modules()
                .into_iter()
                .map(Value::String)
                .collect(),
        ),
    );

    let defaults = default_modules_map();
    for key in [
        "custom/omarchy",
        "hyprland/workspaces",
        "clock",
        "custom/update",
        "custom/screenrecording-indicator",
        "group/tray-expander",
        "custom/expand-icon",
        "tray",
        "bluetooth",
        "network",
        "pulseaudio",
        "cpu",
        "battery",
    ] {
        if let Some(value) = defaults.get(key).cloned() {
            map.insert(key.to_string(), value);
        }
    }

    Value::Object(map)
}

fn default_style_css() -> String {
    generate_style_css(&WaybarGlobals::default(), &BTreeMap::new())
}

fn parse_globals_from_css(css: &str, mut globals: WaybarGlobals) -> WaybarGlobals {
    use regex::Regex;

    // Parse background-color from * selector
    if let Ok(re) = Regex::new(r"\*\s*\{[^}]*background-color:\s*([^;]+);") {
        if let Some(caps) = re.captures(css) {
            if let Some(color) = caps.get(1) {
                globals.background = color.as_str().trim().to_string();
            }
        }
    }

    // Parse color (foreground) from * selector
    if let Ok(re) = Regex::new(r"\*\s*\{[^}]*color:\s*([^;]+);") {
        if let Some(caps) = re.captures(css) {
            if let Some(color) = caps.get(1) {
                globals.foreground = color.as_str().trim().to_string();
            }
        }
    }

    // Parse .modules-left margin-left
    if let Ok(re) = Regex::new(r"\.modules-left\s*\{[^}]*margin-left:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(margin) = caps.get(1) {
                if let Ok(value) = margin.as_str().parse::<f64>() {
                    globals.left_margin = value;
                }
            }
        }
    }

    // Parse .modules-left padding
    if let Ok(re) = Regex::new(r"\.modules-left\s*\{[^}]*padding:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(padding) = caps.get(1) {
                if let Ok(value) = padding.as_str().parse::<f64>() {
                    globals.left_padding = value;
                }
            }
        }
    }

    // Parse .modules-left background
    if let Ok(re) = Regex::new(r"\.modules-left\s*\{[^}]*background:\s*([^;]+);") {
        if let Some(caps) = re.captures(css) {
            if let Some(color) = caps.get(1) {
                globals.left_background = color.as_str().trim().to_string();
            }
        }
    }

    // Parse .modules-center margins
    if let Ok(re) = Regex::new(r"\.modules-center\s*\{[^}]*margin-left:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(margin) = caps.get(1) {
                if let Ok(value) = margin.as_str().parse::<f64>() {
                    globals.center_margin = value;
                }
            }
        }
    }

    // Parse .modules-center padding
    if let Ok(re) = Regex::new(r"\.modules-center\s*\{[^}]*padding:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(padding) = caps.get(1) {
                if let Ok(value) = padding.as_str().parse::<f64>() {
                    globals.center_padding = value;
                }
            }
        }
    }

    // Parse .modules-center background
    if let Ok(re) = Regex::new(r"\.modules-center\s*\{[^}]*background:\s*([^;]+);") {
        if let Some(caps) = re.captures(css) {
            if let Some(color) = caps.get(1) {
                globals.center_background = color.as_str().trim().to_string();
            }
        }
    }

    // Parse .modules-right margin-right
    if let Ok(re) = Regex::new(r"\.modules-right\s*\{[^}]*margin-right:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(margin) = caps.get(1) {
                if let Ok(value) = margin.as_str().parse::<f64>() {
                    globals.right_margin = value;
                }
            }
        }
    }

    // Parse .modules-right padding
    if let Ok(re) = Regex::new(r"\.modules-right\s*\{[^}]*padding:\s*([0-9.]+)px") {
        if let Some(caps) = re.captures(css) {
            if let Some(padding) = caps.get(1) {
                if let Ok(value) = padding.as_str().parse::<f64>() {
                    globals.right_padding = value;
                }
            }
        }
    }

    // Parse .modules-right background
    if let Ok(re) = Regex::new(r"\.modules-right\s*\{[^}]*background:\s*([^;]+);") {
        if let Some(caps) = re.captures(css) {
            if let Some(color) = caps.get(1) {
                globals.right_background = color.as_str().trim().to_string();
            }
        }
    }

    globals
}

// CSS generation has been moved to the frontend (src/lib/utils/waybar/styleGenerator.js)
// The backend now receives the full CSS string directly.
// This function is kept for reference or potential fallback but is no longer the primary generator.
#[allow(dead_code)]
fn generate_module_styles_css(module_styles: &BTreeMap<String, Value>) -> String {
    let mut css = String::new();

    for (module_id, style_obj) in module_styles {
        if let Some(style_map) = style_obj.as_object() {
            if style_map.is_empty() {
                continue;
            }

            // Generate proper CSS selector based on Waybar conventions
            let css_id = if module_id.starts_with("hyprland/") {
                // hyprland/workspaces -> workspaces
                module_id
                    .strip_prefix("hyprland/")
                    .unwrap_or(module_id)
                    .to_string()
            } else if module_id.starts_with("sway/") {
                // sway/workspaces -> workspaces
                module_id
                    .strip_prefix("sway/")
                    .unwrap_or(module_id)
                    .to_string()
            } else {
                // custom/omarchy -> custom-omarchy, others stay the same
                module_id.replace('/', "-")
            };

            // Some modules need specific sub-selectors for certain properties
            // workspaces: font properties go on button, others on the container
            let is_workspaces = css_id == "workspaces";

            // Properties that should go on #workspaces button for workspaces module
            let button_props = ["font-size", "font-weight", "font-family", "color"];

            // Separate properties into container and button styles
            let mut container_styles = Vec::new();
            let mut button_styles = Vec::new();

            for (prop, value) in style_map {
                if let Some(val_str) = value.as_str() {
                    if !val_str.is_empty() {
                        // Convert camelCase to kebab-case
                        let kebab_prop = prop.chars().fold(String::new(), |mut acc, c| {
                            if c.is_uppercase() {
                                acc.push('-');
                                acc.push(c.to_lowercase().next().unwrap());
                            } else {
                                acc.push(c);
                            }
                            acc
                        });

                        if is_workspaces && button_props.contains(&kebab_prop.as_str()) {
                            button_styles.push((kebab_prop, val_str.to_string()));
                        } else {
                            container_styles.push((kebab_prop, val_str.to_string()));
                        }
                    }
                }
            }

            // Generate container styles if any
            if !container_styles.is_empty() {
                css.push_str(&format!("#{} {{\n", css_id));
                for (prop, val) in container_styles {
                    css.push_str(&format!("  {}: {};\n", prop, val));
                }
                css.push_str("}\n\n");
            }

            // Generate button styles for workspaces if any
            if is_workspaces && !button_styles.is_empty() {
                css.push_str(&format!("#{} button {{\n", css_id));
                for (prop, val) in button_styles {
                    css.push_str(&format!("  {}: {};\n", prop, val));
                }
                css.push_str("}\n\n");
            }
        }
    }

    css
}

// CSS generation has been moved to the frontend.
// This function is kept for reference or potential fallback.
#[allow(dead_code)]
fn generate_style_css(globals: &WaybarGlobals, module_styles: &BTreeMap<String, Value>) -> String {
    let mut css = String::new();

    // Import theme variables
    css.push_str("@import \"../omarchy/current/theme/waybar.css\";\n\n");

    // Base styles with custom or theme colors
    css.push_str("* {\n");
    css.push_str(&format!("  background-color: {};\n", globals.background));
    css.push_str(&format!("  color: {};\n", globals.foreground));
    css.push_str("  border: none;\n");
    css.push_str("  border-radius: 0;\n");
    css.push_str("  min-height: 0;\n");
    css.push_str("  font-family: CaskaydiaMono Nerd Font;\n");
    css.push_str("  font-size: 12px;\n");
    css.push_str("}\n\n");

    // Module section styles with custom backgrounds, margins, and padding
    css.push_str(".modules-left {\n");
    css.push_str(&format!("  margin-left: {}px;\n", globals.left_margin));
    if globals.left_padding > 0.0 {
        css.push_str(&format!("  padding: {}px;\n", globals.left_padding));
    }
    if !globals.left_background.is_empty() {
        css.push_str(&format!("  background: {};\n", globals.left_background));
    }
    css.push_str("}\n\n");

    css.push_str(".modules-center {\n");
    css.push_str(&format!("  margin-left: {}px;\n", globals.center_margin));
    css.push_str(&format!("  margin-right: {}px;\n", globals.center_margin));
    if globals.center_padding > 0.0 {
        css.push_str(&format!("  padding: {}px;\n", globals.center_padding));
    }
    if !globals.center_background.is_empty() {
        css.push_str(&format!("  background: {};\n", globals.center_background));
    }
    css.push_str("}\n\n");

    css.push_str(".modules-right {\n");
    css.push_str(&format!("  margin-right: {}px;\n", globals.right_margin));
    if globals.right_padding > 0.0 {
        css.push_str(&format!("  padding: {}px;\n", globals.right_padding));
    }
    if !globals.right_background.is_empty() {
        css.push_str(&format!("  background: {};\n", globals.right_background));
    }
    css.push_str("}\n\n");

    // Module-specific styles
    css.push_str("#workspaces button {\n");
    css.push_str("  all: initial;\n");
    css.push_str("  padding: 0 6px;\n");
    css.push_str("  margin: 0 1.5px;\n");
    css.push_str("  min-width: 9px;\n");
    css.push_str("}\n\n");

    css.push_str("#workspaces button.empty {\n");
    css.push_str("  opacity: 0.5;\n");
    css.push_str("}\n\n");

    css.push_str("#tray,\n");
    css.push_str("#cpu,\n");
    css.push_str("#battery,\n");
    css.push_str("#network,\n");
    css.push_str("#bluetooth,\n");
    css.push_str("#pulseaudio,\n");
    css.push_str("#custom-omarchy,\n");
    css.push_str("#custom-screenrecording-indicator,\n");
    css.push_str("#custom-update {\n");
    css.push_str("  min-width: 12px;\n");
    css.push_str("  margin: 0 7.5px;\n");
    css.push_str("}\n\n");

    css.push_str("#custom-expand-icon {\n");
    css.push_str("  margin-right: 7px;\n");
    css.push_str("}\n\n");

    css.push_str("tooltip {\n");
    css.push_str("  padding: 2px;\n");
    css.push_str("}\n\n");

    css.push_str("#custom-update {\n");
    css.push_str("  font-size: 10px;\n");
    css.push_str("}\n\n");

    css.push_str("#clock {\n");
    css.push_str("  margin-left: 8.75px;\n");
    css.push_str("}\n\n");

    css.push_str(".hidden {\n");
    css.push_str("  opacity: 0;\n");
    css.push_str("}\n\n");

    css.push_str("#custom-screenrecording-indicator {\n");
    css.push_str("  min-width: 12px;\n");
    css.push_str("  margin-left: 8.75px;\n");
    css.push_str("  font-size: 10px;\n");
    css.push_str("}\n\n");

    css.push_str("#custom-screenrecording-indicator.active {\n");
    css.push_str("  color: #a55555;\n");
    css.push_str("}\n\n");

    // Add module-specific styles
    css.push_str(&generate_module_styles_css(module_styles));

    css
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn default_config_contains_known_modules() {
        let value = default_root_value();
        let service = WaybarConfigService {
            config_path: PathBuf::from("/tmp/waybar.jsonc"),
            style_path: PathBuf::from("/tmp/waybar.css"),
            profiles_dir: PathBuf::from("/tmp"),
            manifest_path: PathBuf::from("/tmp/manifest.json"),
            manifest: WaybarProfileManifest::default(),
        };
        let snapshot = service.build_snapshot(
            value.clone(),
            serde_json::to_string_pretty(&value).unwrap(),
            default_style_css(),
            Some(DEFAULT_PROFILE_ID.to_string()),
        );
        assert_eq!(snapshot.layout.left.len(), 2);
        assert_eq!(snapshot.layout.center.len(), 3);
        assert_eq!(snapshot.layout.right.len(), 6);
        assert!(snapshot.modules.contains_key("custom/omarchy"));
    }

    #[test]
    fn default_style_css_contains_expected_content() {
        let css = default_style_css();
        assert!(css.contains("@import"));
        assert!(css.contains("@background"));
        assert!(css.contains("@foreground"));
        assert!(css.contains("#workspaces"));
        assert!(css.contains("#clock"));
        assert!(css.contains("CaskaydiaMono Nerd Font"));
    }

    #[test]
    fn snapshot_includes_style_css() {
        let value = default_root_value();
        let service = WaybarConfigService {
            config_path: PathBuf::from("/tmp/waybar.jsonc"),
            style_path: PathBuf::from("/tmp/waybar.css"),
            profiles_dir: PathBuf::from("/tmp"),
            manifest_path: PathBuf::from("/tmp/manifest.json"),
            manifest: WaybarProfileManifest::default(),
        };
        let css = "/* test css */";
        let snapshot = service.build_snapshot(
            value.clone(),
            serde_json::to_string_pretty(&value).unwrap(),
            css.to_string(),
            Some(DEFAULT_PROFILE_ID.to_string()),
        );
        assert_eq!(snapshot.style_css, css);
    }

    #[test]
    fn parse_globals_from_css_extracts_colors() {
        let css = r#"
* {
  background-color: #ff0000;
  color: #00ff00;
}
.modules-left {
  margin-left: 10px;
  background: #0000ff;
}
"#;
        let globals = WaybarGlobals::default();
        let parsed = parse_globals_from_css(css, globals);

        assert_eq!(parsed.background, "#ff0000");
        assert_eq!(parsed.foreground, "#00ff00");
        assert_eq!(parsed.left_margin, 10.0);
        assert_eq!(parsed.left_background, "#0000ff");
    }

    #[test]
    fn generate_and_parse_css_roundtrip() {
        let mut globals = WaybarGlobals::default();
        globals.background = "#123456".to_string();
        globals.foreground = "#abcdef".to_string();
        globals.left_margin = 15.0;
        globals.left_background = "#fedcba".to_string();

        let css = generate_style_css(&globals, &BTreeMap::new());
        let parsed = parse_globals_from_css(&css, WaybarGlobals::default());

        assert_eq!(parsed.background, globals.background);
        assert_eq!(parsed.foreground, globals.foreground);
        assert_eq!(parsed.left_margin, globals.left_margin);
        assert_eq!(parsed.left_background, globals.left_background);
    }

    #[test]
    fn padding_is_generated_and_parsed() {
        let mut globals = WaybarGlobals::default();
        globals.left_padding = 10.0;
        globals.center_padding = 5.0;
        globals.right_padding = 8.0;

        let css = generate_style_css(&globals, &BTreeMap::new());

        // Verify padding is in CSS
        assert!(css.contains("padding: 10px;"));
        assert!(css.contains("padding: 5px;"));
        assert!(css.contains("padding: 8px;"));

        // Verify round-trip
        let parsed = parse_globals_from_css(&css, WaybarGlobals::default());
        assert_eq!(parsed.left_padding, 10.0);
        assert_eq!(parsed.center_padding, 5.0);
        assert_eq!(parsed.right_padding, 8.0);
    }

    #[test]
    fn zero_padding_is_not_generated() {
        let globals = WaybarGlobals::default(); // All padding is 0.0
        let css = generate_style_css(&globals, &BTreeMap::new());

        // Verify no padding in CSS when it's 0
        assert!(!css.contains("padding:"));
    }

    #[test]
    fn module_styles_generate_correct_css_selectors() {
        let mut module_styles = BTreeMap::new();

        // Test custom module
        let mut custom_style = Map::new();
        custom_style.insert("color".to_string(), Value::String("#ff0000".to_string()));
        module_styles.insert("custom/omarchy".to_string(), Value::Object(custom_style));

        // Test hyprland workspaces with mixed properties
        let mut hyprland_style = Map::new();
        hyprland_style.insert(
            "background".to_string(),
            Value::String("#00ff00".to_string()),
        );
        hyprland_style.insert("fontSize".to_string(), Value::String("16px".to_string()));
        hyprland_style.insert("fontWeight".to_string(), Value::String("bold".to_string()));
        module_styles.insert(
            "hyprland/workspaces".to_string(),
            Value::Object(hyprland_style),
        );

        // Test regular module
        let mut regular_style = Map::new();
        regular_style.insert("fontSize".to_string(), Value::String("14px".to_string()));
        module_styles.insert("clock".to_string(), Value::Object(regular_style));

        let css = generate_module_styles_css(&module_styles);

        // Custom modules: custom/omarchy -> #custom-omarchy
        assert!(css.contains("#custom-omarchy {"));
        assert!(!css.contains("#custom/omarchy"));
        assert!(css.contains("color: #ff0000;"));

        // Hyprland workspaces: hyprland/workspaces -> #workspaces
        // Background goes on container
        assert!(css.contains("#workspaces {"));
        assert!(css.contains("background: #00ff00;"));
        // Font properties go on button
        assert!(css.contains("#workspaces button {"));
        assert!(css.contains("font-size: 16px;"));
        assert!(css.contains("font-weight: bold;"));
        assert!(!css.contains("#hyprland-workspaces"));

        // Regular modules: clock -> #clock (font-size on container)
        assert!(css.contains("#clock {"));
        assert!(css.contains("font-size: 14px;"));
        assert!(!css.contains("#clock button"));
    }

    #[test]
    fn module_styles_converts_camel_case() {
        let mut module_styles = BTreeMap::new();
        let mut style = Map::new();
        style.insert("fontSize".to_string(), Value::String("14px".to_string()));
        style.insert("fontWeight".to_string(), Value::String("bold".to_string()));
        module_styles.insert("clock".to_string(), Value::Object(style));

        let css = generate_module_styles_css(&module_styles);

        assert!(css.contains("#clock {"));
        assert!(css.contains("font-size: 14px;"));
        assert!(css.contains("font-weight: bold;"));
    }

    #[test]
    fn workspaces_button_selector_for_font_properties() {
        let mut module_styles = BTreeMap::new();
        let mut style = Map::new();

        // Font properties should go on button
        style.insert("fontSize".to_string(), Value::String("16px".to_string()));
        style.insert("fontWeight".to_string(), Value::String("bold".to_string()));
        style.insert("color".to_string(), Value::String("#ffffff".to_string()));

        // Non-font properties should go on container
        style.insert(
            "background".to_string(),
            Value::String("#000000".to_string()),
        );
        style.insert("padding".to_string(), Value::String("5px".to_string()));

        module_styles.insert("hyprland/workspaces".to_string(), Value::Object(style));

        let css = generate_module_styles_css(&module_styles);

        // Container styles
        assert!(css.contains("#workspaces {"));
        assert!(css.contains("background: #000000;"));
        assert!(css.contains("padding: 5px;"));

        // Button styles
        assert!(css.contains("#workspaces button {"));
        assert!(css.contains("font-size: 16px;"));
        assert!(css.contains("font-weight: bold;"));
        assert!(css.contains("color: #ffffff;"));
    }
}
