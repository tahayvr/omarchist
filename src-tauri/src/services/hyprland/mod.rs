pub mod keyboard;

use std::collections::BTreeMap;
use std::fs::{self, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::PathBuf;

use log::warn;

use crate::types::{
    animation_field_registry, blur_field_registry, decoration_field_registry,
    general_field_registry, input_field_registry, shadow_field_registry, snap_field_registry,
    touchpad_field_registry, AnimationField, BlurField, DecorationField, GeneralField,
    HyprlandAnimationSettings, HyprlandAnimationSnapshot, HyprlandConfigError,
    HyprlandDecorationOverrideMaps, HyprlandDecorationSettings, HyprlandDecorationSnapshot,
    HyprlandGeneralOverrideMaps, HyprlandGeneralSettings, HyprlandGeneralSnapshot,
    HyprlandInputOverrideMap, HyprlandInputSettings, HyprlandInputSnapshot, HyprlandResult,
    HyprlandValue, InputField, ShadowField, SnapField, TouchpadField,
};

const GENERATED_HEADER: &str = "# Generated by Omarchist - Hyprland overrides";
const GENERATED_HEADER_HINT: &str = "# Manual edits may be overwritten. Use the Omarchist UI.";
const SOURCE_DIRECTIVE: &str = "source = ~/.config/omarchist/hyprland/*";

/// Service responsible for managing Hyprland configuration overrides.
#[derive(Debug, Clone)]
pub struct HyprlandConfigService {
    override_path: PathBuf,
    primary_config_path: PathBuf,
}

impl HyprlandConfigService {
    pub fn new() -> HyprlandResult<Self> {
        let home_dir = dirs::home_dir().ok_or_else(|| {
            HyprlandConfigError::Serialization("Unable to resolve home directory".into())
        })?;
        Ok(Self::build_from_home(home_dir))
    }

    fn build_from_home(home_dir: PathBuf) -> Self {
        let override_path = home_dir.join(".config/omarchist/hyprland/hyprland.conf");
        let primary_config_path = home_dir.join(".config/hypr/hyprland.conf");
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn from_home_dir(home_dir: PathBuf) -> Self {
        Self::build_from_home(home_dir)
    }

    #[cfg(test)]
    pub fn from_paths(primary_config_path: PathBuf, override_path: PathBuf) -> Self {
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn override_path(&self) -> &PathBuf {
        &self.override_path
    }

    #[cfg(test)]
    pub fn primary_config_path(&self) -> &PathBuf {
        &self.primary_config_path
    }

    /// Load explicit overrides and effective values (defaults merged with overrides).
    pub fn load_general_snapshot(&self) -> HyprlandResult<HyprlandGeneralSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.apply_overrides(&parsed.general, &parsed.snap)?;

        let mut effective = HyprlandGeneralSettings::with_defaults();
        effective.apply_overrides(&parsed.general, &parsed.snap)?;

        Ok(HyprlandGeneralSnapshot::new(effective, overrides))
    }

    pub fn load_input_snapshot(&self) -> HyprlandResult<HyprlandInputSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandInputSettings::default();
        overrides.apply_overrides(&parsed.input, &parsed.touchpad)?;

        let mut effective = HyprlandInputSettings::with_defaults();
        effective.apply_overrides(&parsed.input, &parsed.touchpad)?;

        Ok(HyprlandInputSnapshot::new(effective, overrides))
    }

    /// Load explicit decoration overrides merged with defaults.
    pub fn load_decoration_snapshot(&self) -> HyprlandResult<HyprlandDecorationSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandDecorationSettings::default();
        overrides.apply_overrides(&parsed.decoration, &parsed.blur, &parsed.shadow)?;

        let mut effective = HyprlandDecorationSettings::with_defaults();
        effective.apply_overrides(&parsed.decoration, &parsed.blur, &parsed.shadow)?;

        Ok(HyprlandDecorationSnapshot::new(effective, overrides))
    }

    /// Persist the provided overrides to disk, ensuring Hyprland is sourcing the Omarchist file.
    pub fn persist_general_overrides(
        &self,
        overrides: &HyprlandGeneralSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let override_maps = overrides.to_override_maps();
        let decoration_maps = HyprlandDecorationOverrideMaps {
            decoration: parsed.decoration.clone(),
            blur: parsed.blur.clone(),
            shadow: parsed.shadow.clone(),
        };
        let input_map = HyprlandInputOverrideMap {
            settings: parsed.input.clone(),
            touchpad: parsed.touchpad.clone(),
        };

        // Validate values before writing.
        for (key, value) in &override_maps.general {
            if let Some(field) = GeneralField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland key: {key}");
            }
        }

        for (key, value) in &override_maps.snap {
            if let Some(field) = SnapField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland snap key: {key}");
            }
        }

        self.write_override_file(
            &override_maps,
            &decoration_maps,
            &input_map,
            &parsed.animations,
            &parsed.preserved_lines,
        )
    }

    pub fn persist_decoration_overrides(
        &self,
        overrides: &HyprlandDecorationSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let general_maps = HyprlandGeneralOverrideMaps {
            general: parsed.general.clone(),
            snap: parsed.snap.clone(),
        };
        let override_maps = overrides.to_override_maps();
        let input_map = HyprlandInputOverrideMap {
            settings: parsed.input.clone(),
            touchpad: parsed.touchpad.clone(),
        };

        for (key, value) in &override_maps.decoration {
            if let Some(field) = DecorationField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland decoration key: {key}");
            }
        }

        for (key, value) in &override_maps.blur {
            if let Some(field) = BlurField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland blur key: {key}");
            }
        }

        for (key, value) in &override_maps.shadow {
            if let Some(field) = ShadowField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland shadow key: {key}");
            }
        }

        self.write_override_file(
            &general_maps,
            &override_maps,
            &input_map,
            &parsed.animations,
            &parsed.preserved_lines,
        )
    }

    /// Load explicit animation overrides merged with defaults.
    pub fn load_animation_snapshot(&self) -> HyprlandResult<HyprlandAnimationSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandAnimationSettings::default();
        overrides.apply_overrides(&parsed.animations)?;

        let mut effective = HyprlandAnimationSettings::with_defaults();
        effective.apply_overrides(&parsed.animations)?;

        Ok(HyprlandAnimationSnapshot::new(effective, overrides))
    }

    pub fn persist_animation_overrides(
        &self,
        overrides: &HyprlandAnimationSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let general_maps = HyprlandGeneralOverrideMaps {
            general: parsed.general.clone(),
            snap: parsed.snap.clone(),
        };
        let decoration_maps = HyprlandDecorationOverrideMaps {
            decoration: parsed.decoration.clone(),
            blur: parsed.blur.clone(),
            shadow: parsed.shadow.clone(),
        };
        let input_map = HyprlandInputOverrideMap {
            settings: parsed.input.clone(),
            touchpad: parsed.touchpad.clone(),
        };
        let animation_map = overrides.to_override_map();

        for (key, value) in &animation_map {
            if let Some(field) = AnimationField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland animation key: {key}");
            }
        }

        self.write_override_file(
            &general_maps,
            &decoration_maps,
            &input_map,
            &animation_map,
            &parsed.preserved_lines,
        )
    }

    pub fn persist_input_overrides(&self, overrides: &HyprlandInputSettings) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let general_maps = HyprlandGeneralOverrideMaps {
            general: parsed.general.clone(),
            snap: parsed.snap.clone(),
        };
        let decoration_maps = HyprlandDecorationOverrideMaps {
            decoration: parsed.decoration.clone(),
            blur: parsed.blur.clone(),
            shadow: parsed.shadow.clone(),
        };
        let animation_map = parsed.animations.clone();
        let override_map = overrides.to_override_maps();

        for (key, value) in &override_map.settings {
            if let Some(field) = InputField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland input key: {key}");
            }
        }

        for (key, value) in &override_map.touchpad {
            if let Some(field) = TouchpadField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland touchpad key: {key}");
            }
        }

        self.write_override_file(
            &general_maps,
            &decoration_maps,
            &override_map,
            &animation_map,
            &parsed.preserved_lines,
        )
    }

    fn ensure_override_directory(&self) -> HyprlandResult<()> {
        if let Some(parent) = self.override_path.parent() {
            fs::create_dir_all(parent)?;
        }
        Ok(())
    }

    fn ensure_source_directive(&self) -> HyprlandResult<()> {
        if !self.primary_config_path.exists() {
            return Err(HyprlandConfigError::FileNotFound {
                path: self.primary_config_path.display().to_string(),
            });
        }

        let contents = fs::read_to_string(&self.primary_config_path)?;
        let mut has_directive = false;

        for line in contents.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("source") && trimmed.contains(".config/omarchist/hyprland/*")
            {
                has_directive = true;
                break;
            }
        }

        if has_directive {
            return Ok(());
        }

        let mut file = OpenOptions::new()
            .append(true)
            .open(&self.primary_config_path)?;

        writeln!(file, "\n# Added by Omarchist")?;
        writeln!(file, "{SOURCE_DIRECTIVE}")?;

        Ok(())
    }

    fn parse_override_file(&self) -> HyprlandResult<ParsedOverrides> {
        if !self.override_path.exists() {
            return Ok(ParsedOverrides::default());
        }

        let file = OpenOptions::new().read(true).open(&self.override_path)?;
        let reader = BufReader::new(file);

        let mut general_overrides = BTreeMap::new();
        let mut snap_overrides = BTreeMap::new();
        let mut input_overrides = BTreeMap::new();
        let mut touchpad_overrides = BTreeMap::new();
        let mut decoration_overrides = BTreeMap::new();
        let mut blur_overrides = BTreeMap::new();
        let mut shadow_overrides = BTreeMap::new();
        let mut animations_overrides = BTreeMap::new();
        let mut preserved_lines = Vec::new();
        let mut in_general_section = false;
        let mut in_snap_section = false;
        let mut in_input_section = false;
        let mut in_touchpad_section = false;
        let mut in_decoration_section = false;
        let mut in_blur_section = false;
        let mut in_shadow_section = false;
        let mut in_animations_section = false;

        for line in reader.lines() {
            let line = line?;
            let trimmed = line.trim();

            if trimmed.is_empty() {
                continue;
            }

            if trimmed.starts_with('#') {
                if in_general_section
                    || in_snap_section
                    || in_input_section
                    || in_touchpad_section
                    || in_decoration_section
                    || in_blur_section
                    || in_shadow_section
                    || in_animations_section
                {
                    // Drop comments inside managed sections so the formatter can regenerate them.
                    continue;
                }
                if !is_generated_header(trimmed) {
                    preserved_lines.push(line);
                }
                continue;
            }

            if is_section_start(trimmed, "general") {
                in_general_section = true;
                continue;
            }

            if is_section_start(trimmed, "input") {
                in_input_section = true;
                continue;
            }

            if is_section_start(trimmed, "decoration") {
                in_decoration_section = true;
                continue;
            }

            if is_section_start(trimmed, "animations") {
                in_animations_section = true;
                continue;
            }

            if trimmed == "}" {
                if in_touchpad_section {
                    in_touchpad_section = false;
                    continue;
                }

                if in_shadow_section {
                    in_shadow_section = false;
                    continue;
                }

                if in_blur_section {
                    in_blur_section = false;
                    continue;
                }

                if in_snap_section {
                    in_snap_section = false;
                    continue;
                }

                if in_input_section {
                    in_input_section = false;
                    continue;
                }

                if in_decoration_section {
                    in_decoration_section = false;
                    continue;
                }

                if in_animations_section {
                    in_animations_section = false;
                    continue;
                }

                if in_general_section {
                    in_general_section = false;
                    continue;
                }

                preserved_lines.push(line);
                continue;
            }

            if in_general_section && is_section_start(trimmed, "snap") {
                in_snap_section = true;
                continue;
            }

            if in_input_section && is_section_start(trimmed, "touchpad") {
                in_touchpad_section = true;
                continue;
            }

            if in_decoration_section {
                if is_section_start(trimmed, "blur") {
                    in_blur_section = true;
                    continue;
                }

                if is_section_start(trimmed, "shadow") {
                    in_shadow_section = true;
                    continue;
                }
            }

            if !in_general_section
                && !in_snap_section
                && !in_input_section
                && !in_decoration_section
                && !in_animations_section
            {
                preserved_lines.push(line);
                continue;
            }

            let (key, value) = if let Some(parts) = split_kv(trimmed) {
                parts
            } else {
                // Skip lines we cannot parse inside managed sections so the formatter
                // can regenerate them.
                continue;
            };

            if in_snap_section {
                if let Some(field) = SnapField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    snap_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland snap key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_input_section && !in_touchpad_section {
                if let Some(field) = InputField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    input_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland input key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_touchpad_section {
                if let Some(field) = TouchpadField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    touchpad_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland touchpad key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_blur_section {
                if let Some(field) = BlurField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    blur_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland blur key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_shadow_section {
                if let Some(field) = ShadowField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    shadow_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland shadow key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_animations_section {
                if let Some(field) = AnimationField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    animations_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland animations key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_decoration_section {
                if let Some(field) = DecorationField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    decoration_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland decoration key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if let Some(field) = GeneralField::from_key(&key) {
                let parsed_value = field.parse_raw(&value)?;
                general_overrides.insert(field.key().to_string(), parsed_value);
            } else {
                warn!("Encountered unsupported Hyprland key '{key}', preserving original line");
                preserved_lines.push(line);
            }
        }

        Ok(ParsedOverrides {
            general: general_overrides,
            snap: snap_overrides,
            decoration: decoration_overrides,
            blur: blur_overrides,
            shadow: shadow_overrides,
            input: input_overrides,
            touchpad: touchpad_overrides,
            animations: animations_overrides,
            preserved_lines,
        })
    }

    fn write_override_file(
        &self,
        general_overrides: &HyprlandGeneralOverrideMaps,
        decoration_overrides: &HyprlandDecorationOverrideMaps,
        input_overrides: &HyprlandInputOverrideMap,
        animations_overrides: &BTreeMap<String, HyprlandValue>,
        preserved_lines: &[String],
    ) -> HyprlandResult<()> {
        let mut buffer = String::new();
        buffer.push_str(GENERATED_HEADER);
        buffer.push('\n');
        buffer.push_str(GENERATED_HEADER_HINT);
        buffer.push('\n');
        buffer.push('\n');

        buffer.push_str("general {\n");

        let mut wrote_general_entry = false;
        for field in general_field_registry() {
            if let Some(value) = general_overrides.general.get(field.key()) {
                wrote_general_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !general_overrides.snap.is_empty() {
            wrote_general_entry = true;
            buffer.push('\n');
            buffer.push_str("    snap {\n");
            for field in snap_field_registry() {
                if let Some(value) = general_overrides.snap.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !wrote_general_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n\n");

        buffer.push_str("input {\n");

        let mut wrote_input_entry = false;
        for field in input_field_registry() {
            if let Some(value) = input_overrides.settings.get(field.key()) {
                wrote_input_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !input_overrides.touchpad.is_empty() {
            if wrote_input_entry {
                buffer.push('\n');
            }
            wrote_input_entry = true;
            buffer.push_str("    touchpad {\n");
            for field in touchpad_field_registry() {
                if let Some(value) = input_overrides.touchpad.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !wrote_input_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n\n");

        buffer.push_str("decoration {\n");

        let mut wrote_decoration_entry = false;
        for field in decoration_field_registry() {
            if let Some(value) = decoration_overrides.decoration.get(field.key()) {
                wrote_decoration_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !decoration_overrides.blur.is_empty() {
            wrote_decoration_entry = true;
            buffer.push('\n');
            buffer.push_str("    blur {\n");
            for field in blur_field_registry() {
                if let Some(value) = decoration_overrides.blur.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !decoration_overrides.shadow.is_empty() {
            wrote_decoration_entry = true;
            buffer.push('\n');
            buffer.push_str("    shadow {\n");
            for field in shadow_field_registry() {
                if let Some(value) = decoration_overrides.shadow.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !wrote_decoration_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n\n");

        buffer.push_str("animations {\n");

        let mut wrote_animation_entry = false;
        for field in animation_field_registry() {
            if let Some(value) = animations_overrides.get(field.key()) {
                wrote_animation_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !wrote_animation_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n");

        if !preserved_lines.is_empty() {
            buffer.push('\n');
            buffer.push_str("# Preserved entries not managed by Omarchist\n");
            for line in preserved_lines {
                buffer.push_str(line);
                buffer.push('\n');
            }
        }

        self.atomic_write(&buffer)
    }

    fn atomic_write(&self, contents: &str) -> HyprlandResult<()> {
        let parent = self.override_path.parent().ok_or_else(|| {
            HyprlandConfigError::Serialization("Override path missing parent".into())
        })?;

        fs::create_dir_all(parent)?;

        let temp_path = parent.join("hyprland.conf.tmp");
        fs::write(&temp_path, contents)?;
        fs::rename(&temp_path, &self.override_path)?;
        Ok(())
    }
}

#[derive(Default)]
struct ParsedOverrides {
    general: BTreeMap<String, HyprlandValue>,
    snap: BTreeMap<String, HyprlandValue>,
    input: BTreeMap<String, HyprlandValue>,
    touchpad: BTreeMap<String, HyprlandValue>,
    decoration: BTreeMap<String, HyprlandValue>,
    blur: BTreeMap<String, HyprlandValue>,
    shadow: BTreeMap<String, HyprlandValue>,
    animations: BTreeMap<String, HyprlandValue>,
    preserved_lines: Vec<String>,
}

fn split_kv(line: &str) -> Option<(String, String)> {
    if let Some((key, value)) = line.split_once('=') {
        return Some((key.trim().to_string(), value.trim().to_string()));
    }

    let mut parts = line.split_whitespace();
    let key = parts.next()?;
    let value = parts.collect::<Vec<_>>().join(" ");
    if value.is_empty() {
        None
    } else {
        Some((key.trim().to_string(), value.trim().to_string()))
    }
}

fn is_section_start(line: &str, section: &str) -> bool {
    if !line.ends_with('{') {
        return false;
    }

    let without_brace = line[..line.len() - 1].trim_end();
    without_brace.eq_ignore_ascii_case(section)
}

fn is_generated_header(line: &str) -> bool {
    let normalized = line.trim();
    normalized.eq_ignore_ascii_case(GENERATED_HEADER)
        || normalized.eq_ignore_ascii_case(GENERATED_HEADER_HINT)
        || normalized == "# Preserved entries not managed by Omarchist"
}
