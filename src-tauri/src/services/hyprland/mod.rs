use std::collections::BTreeMap;
use std::fs::{self, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::PathBuf;

use log::warn;

use crate::types::{
    general_field_registry,
    GeneralField,
    HyprlandConfigError,
    HyprlandGeneralSettings,
    HyprlandGeneralSnapshot,
    HyprlandResult,
    HyprlandValue,
};

const GENERATED_HEADER: &str = "# Generated by Omarchist - Hyprland overrides";
const GENERATED_HEADER_HINT: &str = "# Manual edits may be overwritten. Use the Omarchist UI.";
const SOURCE_DIRECTIVE: &str = "source = ~/.config/omarchist/hyprland.conf";

/// Service responsible for managing Hyprland configuration overrides.
#[derive(Debug, Clone)]
pub struct HyprlandConfigService {
    override_path: PathBuf,
    primary_config_path: PathBuf,
}

impl HyprlandConfigService {
    pub fn new() -> HyprlandResult<Self> {
        let home_dir = dirs::home_dir().ok_or_else(|| HyprlandConfigError::Serialization("Unable to resolve home directory".into()))?;
        Ok(Self::build_from_home(home_dir))
    }

    fn build_from_home(home_dir: PathBuf) -> Self {
        let override_path = home_dir.join(".config/omarchist/hyprland.conf");
        let primary_config_path = home_dir.join(".config/hypr/hyprland.conf");
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn from_home_dir(home_dir: PathBuf) -> Self {
        Self::build_from_home(home_dir)
    }

    #[cfg(test)]
    pub fn from_paths(primary_config_path: PathBuf, override_path: PathBuf) -> Self {
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn override_path(&self) -> &PathBuf {
        &self.override_path
    }

    #[cfg(test)]
    pub fn primary_config_path(&self) -> &PathBuf {
        &self.primary_config_path
    }

    /// Load explicit overrides and effective values (defaults merged with overrides).
    pub fn load_general_snapshot(&self) -> HyprlandResult<HyprlandGeneralSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.apply_overrides(&parsed.overrides)?;

        let mut effective = HyprlandGeneralSettings::with_defaults();
        effective.apply_overrides(&parsed.overrides)?;

        Ok(HyprlandGeneralSnapshot::new(effective, overrides))
    }

    /// Persist the provided overrides to disk, ensuring Hyprland is sourcing the Omarchist file.
    pub fn persist_general_overrides(&self, overrides: &HyprlandGeneralSettings) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let override_map = overrides.to_override_map();

        // Validate values before writing.
        for (key, value) in &override_map {
            if let Some(field) = GeneralField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland key: {key}");
            }
        }

        self.write_override_file(&override_map, &parsed.preserved_lines)
    }

    fn ensure_override_directory(&self) -> HyprlandResult<()> {
        if let Some(parent) = self.override_path.parent() {
            fs::create_dir_all(parent)?;
        }
        Ok(())
    }

    fn ensure_source_directive(&self) -> HyprlandResult<()> {
        if !self.primary_config_path.exists() {
            return Err(HyprlandConfigError::FileNotFound {
                path: self.primary_config_path.display().to_string(),
            });
        }

        let contents = fs::read_to_string(&self.primary_config_path)?;
        let mut has_directive = false;

        for line in contents.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("source") && trimmed.contains(".config/omarchist/hyprland.conf") {
                has_directive = true;
                break;
            }
        }

        if has_directive {
            return Ok(());
        }

        let mut file = OpenOptions::new()
            .append(true)
            .open(&self.primary_config_path)?;

        writeln!(file, "\n# Added by Omarchist - ensure overrides are applied")?;
        writeln!(file, "{SOURCE_DIRECTIVE}")?;

        Ok(())
    }

    fn parse_override_file(&self) -> HyprlandResult<ParsedOverrides> {
        if !self.override_path.exists() {
            return Ok(ParsedOverrides::default());
        }

        let file = OpenOptions::new().read(true).open(&self.override_path)?;
        let reader = BufReader::new(file);

        let mut overrides = BTreeMap::new();
        let mut preserved_lines = Vec::new();

        for line in reader.lines() {
            let line = line?;
            let trimmed = line.trim();

            if trimmed.is_empty() {
                continue;
            }

            if trimmed.starts_with('#') {
                if !is_generated_header(trimmed) {
                    preserved_lines.push(line);
                }
                continue;
            }

            let (key, value) = if let Some(parts) = split_kv(&line) {
                parts
            } else {
                preserved_lines.push(line);
                continue;
            };

            if let Some(field) = GeneralField::from_key(&key) {
                let parsed_value = field.parse_raw(&value)?;
                overrides.insert(field.key().to_string(), parsed_value);
            } else {
                warn!("Encountered unsupported Hyprland key '{key}', preserving original line");
                preserved_lines.push(line);
            }
        }

        Ok(ParsedOverrides {
            overrides,
            preserved_lines,
        })
    }

    fn write_override_file(
        &self,
        overrides: &BTreeMap<String, HyprlandValue>,
        preserved_lines: &[String],
    ) -> HyprlandResult<()> {
        let mut buffer = String::new();
        buffer.push_str(GENERATED_HEADER);
        buffer.push('\n');
        buffer.push_str(GENERATED_HEADER_HINT);
        buffer.push('\n');
        buffer.push('\n');

        for field in general_field_registry() {
            if let Some(value) = overrides.get(field.key()) {
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !preserved_lines.is_empty() {
            buffer.push('\n');
            buffer.push_str("# Preserved entries not managed by Omarchist\n");
            for line in preserved_lines {
                buffer.push_str(line);
                buffer.push('\n');
            }
        }

        self.atomic_write(&buffer)
    }

    fn atomic_write(&self, contents: &str) -> HyprlandResult<()> {
        let parent = self
            .override_path
            .parent()
            .ok_or_else(|| HyprlandConfigError::Serialization("Override path missing parent".into()))?;

        fs::create_dir_all(parent)?;

        let temp_path = parent.join("hyprland.conf.tmp");
        fs::write(&temp_path, contents)?;
        fs::rename(&temp_path, &self.override_path)?;
        Ok(())
    }
}

#[derive(Default)]
struct ParsedOverrides {
    overrides: BTreeMap<String, HyprlandValue>,
    preserved_lines: Vec<String>,
}

fn split_kv(line: &str) -> Option<(String, String)> {
    if let Some((key, value)) = line.split_once('=') {
        return Some((key.trim().to_string(), value.trim().to_string()));
    }

    let mut parts = line.split_whitespace();
    let key = parts.next()?;
    let value = parts.collect::<Vec<_>>().join(" ");
    if value.is_empty() {
        None
    } else {
        Some((key.trim().to_string(), value.trim().to_string()))
    }
}

fn is_generated_header(line: &str) -> bool {
    let normalized = line.trim();
    normalized.eq_ignore_ascii_case(GENERATED_HEADER)
        || normalized.eq_ignore_ascii_case(GENERATED_HEADER_HINT)
        || normalized == "# Preserved entries not managed by Omarchist"
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    use crate::types::LayoutMode;
    use tempfile::TempDir;

    fn setup_service() -> (TempDir, HyprlandConfigService) {
        let temp_dir = TempDir::new().expect("create temp dir");
        let home = temp_dir.path().to_path_buf();
        let hypr_dir = home.join(".config/hypr");
        fs::create_dir_all(&hypr_dir).expect("create hypr dir");
        let primary_config = hypr_dir.join("hyprland.conf");
        fs::write(&primary_config, "# hyprland config\n").expect("write primary config");

        let service = HyprlandConfigService::from_home_dir(home);
        (temp_dir, service)
    }

    #[test]
    fn snapshot_returns_defaults_when_no_overrides() {
        let (_temp_dir, service) = setup_service();
        let snapshot = service.load_general_snapshot().expect("load snapshot");

        assert_eq!(snapshot.overrides, HyprlandGeneralSettings::default());
        let defaults = HyprlandGeneralSettings::with_defaults();
        assert_eq!(snapshot.effective, defaults);
    }

    #[test]
    fn persist_writes_overrides_and_source_directive() {
    let (_temp_dir, service) = setup_service();

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.layout = Some(LayoutMode::Master);
        overrides.hover_icon_on_border = Some(false);
        overrides.extend_border_grab_area = Some(25);

        service
            .persist_general_overrides(&overrides)
            .expect("persist overrides");

        // Verify override file contents
        let override_contents =
            fs::read_to_string(service.override_path()).expect("read override file");
        assert!(override_contents.contains("layout = master"));
        assert!(override_contents.contains("hover_icon_on_border = false"));
        assert!(override_contents.contains("extend_border_grab_area = 25"));

        // Verify source directive appended only once
        let primary_contents =
            fs::read_to_string(service.primary_config_path()).expect("read primary config");
        let occurrences = primary_contents.matches(SOURCE_DIRECTIVE).count();
        assert_eq!(occurrences, 1);

        // Snapshot reflects persisted overrides
        let snapshot = service.load_general_snapshot().expect("reload snapshot");
        assert_eq!(snapshot.overrides.layout, Some(LayoutMode::Master));
        assert_eq!(snapshot.overrides.hover_icon_on_border, Some(false));
        assert_eq!(snapshot.overrides.extend_border_grab_area, Some(25));
    }

    #[test]
    fn preserves_unknown_override_lines() {
        let (_temp_dir, service) = setup_service();

        let override_dir = service
            .override_path()
            .parent()
            .expect("override dir parent")
            .to_path_buf();
        fs::create_dir_all(&override_dir).expect("create override dir");
        fs::write(
            service.override_path(),
            "custom_setting = value\n# user comment\n",
        )
        .expect("seed override file");

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.allow_tearing = Some(true);

        service
            .persist_general_overrides(&overrides)
            .expect("persist overrides with unknown lines");

        let override_contents =
            fs::read_to_string(service.override_path()).expect("read override");
        assert!(override_contents.contains("allow_tearing = true"));
        assert!(override_contents.contains("custom_setting = value"));
        assert!(override_contents.contains("# user comment"));

        // Ensure preserved section header present when unknown lines exist
        assert!(override_contents.contains("# Preserved entries not managed by Omarchist"));
    }
}