use std::collections::BTreeMap;
use std::fs::{self, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::PathBuf;

use log::warn;

use crate::types::{
    animation_field_registry, blur_field_registry, decoration_field_registry,
    general_field_registry, shadow_field_registry, snap_field_registry, AnimationField, BlurField,
    DecorationField, GeneralField, HyprlandAnimationSettings, HyprlandAnimationSnapshot,
    HyprlandConfigError, HyprlandDecorationOverrideMaps, HyprlandDecorationSettings,
    HyprlandDecorationSnapshot, HyprlandGeneralOverrideMaps, HyprlandGeneralSettings,
    HyprlandGeneralSnapshot, HyprlandResult, HyprlandValue, ShadowField, SnapField,
};

const GENERATED_HEADER: &str = "# Generated by Omarchist - Hyprland overrides";
const GENERATED_HEADER_HINT: &str = "# Manual edits may be overwritten. Use the Omarchist UI.";
const SOURCE_DIRECTIVE: &str = "source = ~/.config/omarchist/hyprland.conf";

/// Service responsible for managing Hyprland configuration overrides.
#[derive(Debug, Clone)]
pub struct HyprlandConfigService {
    override_path: PathBuf,
    primary_config_path: PathBuf,
}

impl HyprlandConfigService {
    pub fn new() -> HyprlandResult<Self> {
        let home_dir = dirs::home_dir().ok_or_else(|| {
            HyprlandConfigError::Serialization("Unable to resolve home directory".into())
        })?;
        Ok(Self::build_from_home(home_dir))
    }

    fn build_from_home(home_dir: PathBuf) -> Self {
        let override_path = home_dir.join(".config/omarchist/hyprland.conf");
        let primary_config_path = home_dir.join(".config/hypr/hyprland.conf");
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn from_home_dir(home_dir: PathBuf) -> Self {
        Self::build_from_home(home_dir)
    }

    #[cfg(test)]
    pub fn from_paths(primary_config_path: PathBuf, override_path: PathBuf) -> Self {
        Self {
            override_path,
            primary_config_path,
        }
    }

    #[cfg(test)]
    pub fn override_path(&self) -> &PathBuf {
        &self.override_path
    }

    #[cfg(test)]
    pub fn primary_config_path(&self) -> &PathBuf {
        &self.primary_config_path
    }

    /// Load explicit overrides and effective values (defaults merged with overrides).
    pub fn load_general_snapshot(&self) -> HyprlandResult<HyprlandGeneralSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.apply_overrides(&parsed.general, &parsed.snap)?;

        let mut effective = HyprlandGeneralSettings::with_defaults();
        effective.apply_overrides(&parsed.general, &parsed.snap)?;

        Ok(HyprlandGeneralSnapshot::new(effective, overrides))
    }

    /// Load explicit decoration overrides merged with defaults.
    pub fn load_decoration_snapshot(&self) -> HyprlandResult<HyprlandDecorationSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandDecorationSettings::default();
        overrides.apply_overrides(&parsed.decoration, &parsed.blur, &parsed.shadow)?;

        let mut effective = HyprlandDecorationSettings::with_defaults();
        effective.apply_overrides(&parsed.decoration, &parsed.blur, &parsed.shadow)?;

        Ok(HyprlandDecorationSnapshot::new(effective, overrides))
    }

    /// Persist the provided overrides to disk, ensuring Hyprland is sourcing the Omarchist file.
    pub fn persist_general_overrides(
        &self,
        overrides: &HyprlandGeneralSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let override_maps = overrides.to_override_maps();
        let decoration_maps = HyprlandDecorationOverrideMaps {
            decoration: parsed.decoration.clone(),
            blur: parsed.blur.clone(),
            shadow: parsed.shadow.clone(),
        };

        // Validate values before writing.
        for (key, value) in &override_maps.general {
            if let Some(field) = GeneralField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland key: {key}");
            }
        }

        for (key, value) in &override_maps.snap {
            if let Some(field) = SnapField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland snap key: {key}");
            }
        }

        self.write_override_file(
            &override_maps,
            &decoration_maps,
            &parsed.animations,
            &parsed.preserved_lines,
        )
    }

    pub fn persist_decoration_overrides(
        &self,
        overrides: &HyprlandDecorationSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let general_maps = HyprlandGeneralOverrideMaps {
            general: parsed.general.clone(),
            snap: parsed.snap.clone(),
        };
        let override_maps = overrides.to_override_maps();

        for (key, value) in &override_maps.decoration {
            if let Some(field) = DecorationField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland decoration key: {key}");
            }
        }

        for (key, value) in &override_maps.blur {
            if let Some(field) = BlurField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland blur key: {key}");
            }
        }

        for (key, value) in &override_maps.shadow {
            if let Some(field) = ShadowField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland shadow key: {key}");
            }
        }

        self.write_override_file(
            &general_maps,
            &override_maps,
            &parsed.animations,
            &parsed.preserved_lines,
        )
    }

    /// Load explicit animation overrides merged with defaults.
    pub fn load_animation_snapshot(&self) -> HyprlandResult<HyprlandAnimationSnapshot> {
        let parsed = self.parse_override_file()?;

        let mut overrides = HyprlandAnimationSettings::default();
        overrides.apply_overrides(&parsed.animations)?;

        let mut effective = HyprlandAnimationSettings::with_defaults();
        effective.apply_overrides(&parsed.animations)?;

        Ok(HyprlandAnimationSnapshot::new(effective, overrides))
    }

    pub fn persist_animation_overrides(
        &self,
        overrides: &HyprlandAnimationSettings,
    ) -> HyprlandResult<()> {
        self.ensure_override_directory()?;
        self.ensure_source_directive()?;

        let parsed = self.parse_override_file()?;
        let general_maps = HyprlandGeneralOverrideMaps {
            general: parsed.general.clone(),
            snap: parsed.snap.clone(),
        };
        let decoration_maps = HyprlandDecorationOverrideMaps {
            decoration: parsed.decoration.clone(),
            blur: parsed.blur.clone(),
            shadow: parsed.shadow.clone(),
        };
        let animation_map = overrides.to_override_map();

        for (key, value) in &animation_map {
            if let Some(field) = AnimationField::from_key(key) {
                field.validate(value)?;
            } else {
                warn!("Ignoring attempt to persist unsupported Hyprland animation key: {key}");
            }
        }

        self.write_override_file(
            &general_maps,
            &decoration_maps,
            &animation_map,
            &parsed.preserved_lines,
        )
    }

    fn ensure_override_directory(&self) -> HyprlandResult<()> {
        if let Some(parent) = self.override_path.parent() {
            fs::create_dir_all(parent)?;
        }
        Ok(())
    }

    fn ensure_source_directive(&self) -> HyprlandResult<()> {
        if !self.primary_config_path.exists() {
            return Err(HyprlandConfigError::FileNotFound {
                path: self.primary_config_path.display().to_string(),
            });
        }

        let contents = fs::read_to_string(&self.primary_config_path)?;
        let mut has_directive = false;

        for line in contents.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("source")
                && trimmed.contains(".config/omarchist/hyprland.conf")
            {
                has_directive = true;
                break;
            }
        }

        if has_directive {
            return Ok(());
        }

        let mut file = OpenOptions::new()
            .append(true)
            .open(&self.primary_config_path)?;

        writeln!(
            file,
            "\n# Added by Omarchist - ensure overrides are applied"
        )?;
        writeln!(file, "{SOURCE_DIRECTIVE}")?;

        Ok(())
    }

    fn parse_override_file(&self) -> HyprlandResult<ParsedOverrides> {
        if !self.override_path.exists() {
            return Ok(ParsedOverrides::default());
        }

        let file = OpenOptions::new().read(true).open(&self.override_path)?;
        let reader = BufReader::new(file);

        let mut general_overrides = BTreeMap::new();
        let mut snap_overrides = BTreeMap::new();
        let mut decoration_overrides = BTreeMap::new();
        let mut blur_overrides = BTreeMap::new();
        let mut shadow_overrides = BTreeMap::new();
        let mut animations_overrides = BTreeMap::new();
        let mut preserved_lines = Vec::new();
        let mut in_general_section = false;
        let mut in_snap_section = false;
        let mut in_decoration_section = false;
        let mut in_blur_section = false;
        let mut in_shadow_section = false;
        let mut in_animations_section = false;

        for line in reader.lines() {
            let line = line?;
            let trimmed = line.trim();

            if trimmed.is_empty() {
                continue;
            }

            if trimmed.starts_with('#') {
                if in_general_section
                    || in_snap_section
                    || in_decoration_section
                    || in_blur_section
                    || in_shadow_section
                    || in_animations_section
                {
                    // Drop comments inside managed sections so the formatter can regenerate them.
                    continue;
                }
                if !is_generated_header(trimmed) {
                    preserved_lines.push(line);
                }
                continue;
            }

            if is_section_start(trimmed, "general") {
                in_general_section = true;
                continue;
            }

            if is_section_start(trimmed, "decoration") {
                in_decoration_section = true;
                continue;
            }

            if is_section_start(trimmed, "animations") {
                in_animations_section = true;
                continue;
            }

            if trimmed == "}" {
                if in_shadow_section {
                    in_shadow_section = false;
                    continue;
                }

                if in_blur_section {
                    in_blur_section = false;
                    continue;
                }

                if in_snap_section {
                    in_snap_section = false;
                    continue;
                }

                if in_decoration_section {
                    in_decoration_section = false;
                    continue;
                }

                if in_animations_section {
                    in_animations_section = false;
                    continue;
                }

                if in_general_section {
                    in_general_section = false;
                    continue;
                }

                preserved_lines.push(line);
                continue;
            }

            if in_general_section && is_section_start(trimmed, "snap") {
                in_snap_section = true;
                continue;
            }

            if in_decoration_section {
                if is_section_start(trimmed, "blur") {
                    in_blur_section = true;
                    continue;
                }

                if is_section_start(trimmed, "shadow") {
                    in_shadow_section = true;
                    continue;
                }
            }

            if !in_general_section && !in_decoration_section && !in_animations_section {
                preserved_lines.push(line);
                continue;
            }

            let (key, value) = if let Some(parts) = split_kv(trimmed) {
                parts
            } else {
                // Skip lines we cannot parse inside managed sections so the formatter
                // can regenerate them.
                continue;
            };

            if in_snap_section {
                if let Some(field) = SnapField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    snap_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland snap key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_blur_section {
                if let Some(field) = BlurField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    blur_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland blur key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_shadow_section {
                if let Some(field) = ShadowField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    shadow_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland shadow key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_animations_section {
                if let Some(field) = AnimationField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    animations_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland animations key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if in_decoration_section {
                if let Some(field) = DecorationField::from_key(&key) {
                    let parsed_value = field.parse_raw(&value)?;
                    decoration_overrides.insert(field.key().to_string(), parsed_value);
                } else {
                    warn!(
                        "Encountered unsupported Hyprland decoration key '{key}', preserving original line"
                    );
                    preserved_lines.push(line);
                }
                continue;
            }

            if let Some(field) = GeneralField::from_key(&key) {
                let parsed_value = field.parse_raw(&value)?;
                general_overrides.insert(field.key().to_string(), parsed_value);
            } else {
                warn!("Encountered unsupported Hyprland key '{key}', preserving original line");
                preserved_lines.push(line);
            }
        }

        Ok(ParsedOverrides {
            general: general_overrides,
            snap: snap_overrides,
            decoration: decoration_overrides,
            blur: blur_overrides,
            shadow: shadow_overrides,
            animations: animations_overrides,
            preserved_lines,
        })
    }

    fn write_override_file(
        &self,
        general_overrides: &HyprlandGeneralOverrideMaps,
        decoration_overrides: &HyprlandDecorationOverrideMaps,
        animations_overrides: &BTreeMap<String, HyprlandValue>,
        preserved_lines: &[String],
    ) -> HyprlandResult<()> {
        let mut buffer = String::new();
        buffer.push_str(GENERATED_HEADER);
        buffer.push('\n');
        buffer.push_str(GENERATED_HEADER_HINT);
        buffer.push('\n');
        buffer.push('\n');

        buffer.push_str("general {\n");

        let mut wrote_general_entry = false;
        for field in general_field_registry() {
            if let Some(value) = general_overrides.general.get(field.key()) {
                wrote_general_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !general_overrides.snap.is_empty() {
            wrote_general_entry = true;
            buffer.push('\n');
            buffer.push_str("    snap {\n");
            for field in snap_field_registry() {
                if let Some(value) = general_overrides.snap.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !wrote_general_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n\n");

        buffer.push_str("decoration {\n");

        let mut wrote_decoration_entry = false;
        for field in decoration_field_registry() {
            if let Some(value) = decoration_overrides.decoration.get(field.key()) {
                wrote_decoration_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !decoration_overrides.blur.is_empty() {
            wrote_decoration_entry = true;
            buffer.push('\n');
            buffer.push_str("    blur {\n");
            for field in blur_field_registry() {
                if let Some(value) = decoration_overrides.blur.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !decoration_overrides.shadow.is_empty() {
            wrote_decoration_entry = true;
            buffer.push('\n');
            buffer.push_str("    shadow {\n");
            for field in shadow_field_registry() {
                if let Some(value) = decoration_overrides.shadow.get(field.key()) {
                    buffer.push_str("        ");
                    buffer.push_str(field.key());
                    buffer.push_str(" = ");
                    buffer.push_str(&value.to_string());
                    buffer.push('\n');
                }
            }
            buffer.push_str("    }\n");
        }

        if !wrote_decoration_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n\n");

        buffer.push_str("animations {\n");

        let mut wrote_animation_entry = false;
        for field in animation_field_registry() {
            if let Some(value) = animations_overrides.get(field.key()) {
                wrote_animation_entry = true;
                buffer.push_str("    ");
                buffer.push_str(field.key());
                buffer.push_str(" = ");
                buffer.push_str(&value.to_string());
                buffer.push('\n');
            }
        }

        if !wrote_animation_entry {
            buffer.push_str("    # No overrides currently managed by Omarchist\n");
        }

        buffer.push_str("}\n");

        if !preserved_lines.is_empty() {
            buffer.push('\n');
            buffer.push_str("# Preserved entries not managed by Omarchist\n");
            for line in preserved_lines {
                buffer.push_str(line);
                buffer.push('\n');
            }
        }

        self.atomic_write(&buffer)
    }

    fn atomic_write(&self, contents: &str) -> HyprlandResult<()> {
        let parent = self.override_path.parent().ok_or_else(|| {
            HyprlandConfigError::Serialization("Override path missing parent".into())
        })?;

        fs::create_dir_all(parent)?;

        let temp_path = parent.join("hyprland.conf.tmp");
        fs::write(&temp_path, contents)?;
        fs::rename(&temp_path, &self.override_path)?;
        Ok(())
    }
}

#[derive(Default)]
struct ParsedOverrides {
    general: BTreeMap<String, HyprlandValue>,
    snap: BTreeMap<String, HyprlandValue>,
    decoration: BTreeMap<String, HyprlandValue>,
    blur: BTreeMap<String, HyprlandValue>,
    shadow: BTreeMap<String, HyprlandValue>,
    animations: BTreeMap<String, HyprlandValue>,
    preserved_lines: Vec<String>,
}

fn split_kv(line: &str) -> Option<(String, String)> {
    if let Some((key, value)) = line.split_once('=') {
        return Some((key.trim().to_string(), value.trim().to_string()));
    }

    let mut parts = line.split_whitespace();
    let key = parts.next()?;
    let value = parts.collect::<Vec<_>>().join(" ");
    if value.is_empty() {
        None
    } else {
        Some((key.trim().to_string(), value.trim().to_string()))
    }
}

fn is_section_start(line: &str, section: &str) -> bool {
    if !line.ends_with('{') {
        return false;
    }

    let without_brace = line[..line.len() - 1].trim_end();
    without_brace.eq_ignore_ascii_case(section)
}

fn is_generated_header(line: &str) -> bool {
    let normalized = line.trim();
    normalized.eq_ignore_ascii_case(GENERATED_HEADER)
        || normalized.eq_ignore_ascii_case(GENERATED_HEADER_HINT)
        || normalized == "# Preserved entries not managed by Omarchist"
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    use crate::types::{HyprlandDecorationSettings, LayoutMode};
    use tempfile::TempDir;

    fn setup_service() -> (TempDir, HyprlandConfigService) {
        let temp_dir = TempDir::new().expect("create temp dir");
        let home = temp_dir.path().to_path_buf();
        let hypr_dir = home.join(".config/hypr");
        fs::create_dir_all(&hypr_dir).expect("create hypr dir");
        let primary_config = hypr_dir.join("hyprland.conf");
        fs::write(&primary_config, "# hyprland config\n").expect("write primary config");

        let service = HyprlandConfigService::from_home_dir(home);
        (temp_dir, service)
    }

    #[test]
    fn snapshot_returns_defaults_when_no_overrides() {
        let (_temp_dir, service) = setup_service();
        let snapshot = service.load_general_snapshot().expect("load snapshot");

        assert_eq!(snapshot.overrides, HyprlandGeneralSettings::default());
        let defaults = HyprlandGeneralSettings::with_defaults();
        assert_eq!(snapshot.effective, defaults);
    }

    #[test]
    fn decoration_snapshot_returns_defaults_when_no_overrides() {
        let (_temp_dir, service) = setup_service();
        let snapshot = service
            .load_decoration_snapshot()
            .expect("load decoration snapshot");

        assert_eq!(snapshot.overrides, HyprlandDecorationSettings::default());
        let defaults = HyprlandDecorationSettings::with_defaults();
        assert_eq!(snapshot.effective, defaults);
    }

    #[test]
    fn persist_writes_overrides_and_source_directive() {
        let (_temp_dir, service) = setup_service();

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.layout = Some(LayoutMode::Master);
        overrides.hover_icon_on_border = Some(false);
        overrides.extend_border_grab_area = Some(25);
        overrides.snap.enabled = Some(true);
        overrides.snap.window_gap = Some(18);
        overrides.snap.respect_gaps = Some(true);

        service
            .persist_general_overrides(&overrides)
            .expect("persist overrides");

        // Verify override file contents
        let override_contents =
            fs::read_to_string(service.override_path()).expect("read override file");
        assert!(override_contents.contains("\ngeneral {\n"));
        assert!(override_contents.contains("layout = master"));
        assert!(override_contents.contains("hover_icon_on_border = false"));
        assert!(override_contents.contains("extend_border_grab_area = 25"));
        assert!(override_contents.contains("    snap {"));
        assert!(override_contents.contains("enabled = true"));
        assert!(override_contents.contains("window_gap = 18"));
        assert!(override_contents.contains("respect_gaps = true"));
    assert!(override_contents.contains("\ndecoration {\n"));
    assert!(override_contents.contains("    # No overrides currently managed by Omarchist"));
    assert!(override_contents.contains("\n}\n"));

        // Verify source directive appended only once
        let primary_contents =
            fs::read_to_string(service.primary_config_path()).expect("read primary config");
        let occurrences = primary_contents.matches(SOURCE_DIRECTIVE).count();
        assert_eq!(occurrences, 1);

        // Snapshot reflects persisted overrides
        let snapshot = service.load_general_snapshot().expect("reload snapshot");
        assert_eq!(snapshot.overrides.layout, Some(LayoutMode::Master));
        assert_eq!(snapshot.overrides.hover_icon_on_border, Some(false));
        assert_eq!(snapshot.overrides.extend_border_grab_area, Some(25));
        assert_eq!(snapshot.overrides.snap.enabled, Some(true));
        assert_eq!(snapshot.overrides.snap.window_gap, Some(18));
        assert_eq!(snapshot.overrides.snap.respect_gaps, Some(true));
    }

    #[test]
    fn persist_decoration_overrides_and_snapshot() {
        let (_temp_dir, service) = setup_service();

        let mut overrides = HyprlandDecorationSettings::default();
        overrides.rounding = Some(6);
        overrides.active_opacity = Some(0.8);
        overrides.blur.size = Some(14);
        overrides.blur.enabled = Some(true);
        overrides.shadow.color = Some("0xffaabbcc".into());
        overrides.shadow.scale = Some(0.75);

        service
            .persist_decoration_overrides(&overrides)
            .expect("persist decoration overrides");

        let override_contents =
            fs::read_to_string(service.override_path()).expect("read override file");
        assert!(override_contents.contains("\ngeneral {\n    # No overrides currently managed by Omarchist"));
        assert!(override_contents.contains("\ndecoration {\n"));
        assert!(override_contents.contains("rounding = 6"));
        assert!(override_contents.contains("active_opacity = 0.8"));
        assert!(override_contents.contains("    blur {"));
        assert!(override_contents.contains("size = 14"));
        assert!(override_contents.contains("enabled = true"));
        assert!(override_contents.contains("    shadow {"));
        assert!(override_contents.contains("color = 0xffaabbcc"));
        assert!(override_contents.contains("scale = 0.75"));

        let snapshot = service
            .load_decoration_snapshot()
            .expect("reload decoration snapshot");
        assert_eq!(snapshot.overrides.rounding, Some(6));
        assert_eq!(snapshot.overrides.active_opacity, Some(0.8));
        assert_eq!(snapshot.overrides.blur.size, Some(14));
        assert_eq!(snapshot.overrides.blur.enabled, Some(true));
        assert_eq!(snapshot.overrides.shadow.color, Some("0xffaabbcc".into()));
        assert_eq!(snapshot.overrides.shadow.scale, Some(0.75));
    }

    #[test]
    fn preserves_unknown_override_lines() {
        let (_temp_dir, service) = setup_service();

        let override_dir = service
            .override_path()
            .parent()
            .expect("override dir parent")
            .to_path_buf();
        fs::create_dir_all(&override_dir).expect("create override dir");
        fs::write(
            service.override_path(),
            "custom_setting = value\n# user comment\n",
        )
        .expect("seed override file");

        let mut overrides = HyprlandGeneralSettings::default();
        overrides.allow_tearing = Some(true);

        service
            .persist_general_overrides(&overrides)
            .expect("persist overrides with unknown lines");

        let override_contents = fs::read_to_string(service.override_path()).expect("read override");
        assert!(override_contents.contains("\ngeneral {\n"));
        assert!(override_contents.contains("allow_tearing = true"));
        assert!(override_contents.contains("custom_setting = value"));
        assert!(override_contents.contains("# user comment"));

        // Ensure preserved section header present when unknown lines exist
        assert!(override_contents.contains("# Preserved entries not managed by Omarchist"));
    }
}
